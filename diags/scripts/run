#!/usr/bin/perl

# Name:     run
# Author:   Trevor Williams  <trevorw(sgi.com)>
# Date:     2/11/2005
# Brief:    Script used for running both regressions and single diagnostics.
# Usage:    run <list_of_groups>

# Defines
$covered = "../../src/covered";

# Global variables
$gflag         = "-Q";
%groups_plus   = ();
%groups_minus  = ();
@groups_to_run = ();
%sim_cmds      = ();
%score_cmds    = ();
%score_output  = ();
%merge_cmds    = ();
%merge_output  = ();
%report_cmds   = ();
%report_output = ();
@passed_diags  = ();
@failed_diags  = ();
$merge_set     = 0;
$report_set    = 0;

if( $env{"COVERED_GFLAG"} ne "" ) {
  $gflag = $env{"COVERED_GFLAG"};
}

# Parse command-line arguments
&parse_args;

# Run diagnostics
&run_diags;

# Output the results
&output_results;

###################################################################3

sub parse_args {

  foreach $arg (@ARGV) {
    if( $arg =~ /^\+(.*)/ ) {
      $groups_plus{$1} = 1;
    } elsif( $arg =~ /^\-(.*)/ ) {
      $groups_minus{$1} = 1;
    } else {
      &usage;
    }
  }

}

sub usage {

  print "Usage:  run <list_of_groups>\n";
  die;

}

sub parse_groups {

  my @line = split( /\s+/, $_[0] );
  my $run  = 0;
  my $group;

  foreach $group (@line) {
    if( $groups_plus{$group} ne "" ) {
      $groups_to_run[@groups_to_run] = $group;
      $run = 1;
    }
  }

  return( $run );

}

sub parse_cmd {

  my $line = $_[0];
  my $run, $cmd;
  my $prereq_list, $cmd_list, $output, $retval, @list;

  # Split line based on the colon character
  ($prereq_list,$cmd_list,$output,$retval) = split( /:/, $line );

  # Remove unnecessary spaces from cmd_list
  $cmd_list =~ s/^ +//g;
  $cmd_list =~ s/; +/; /g;
  $cmd_list =~ s/ +$//g;

  # Remove unnecessary spaces from return value
  if( $retval eq "" ) {
    $retval = 0;
  } else {
    $retval =~ s/ //g;
  }

  # Parse prerequisite list
  @list = split( /\s+/, $prereq_list );
  $run  = 1;
  $cmd  = shift( @list );

  if( $cmd eq "SIM" ) {
    $sim_cmds{"@list"}      = "$cmd_list;";
    $sim_output{"@list"}    = $output;
    $sim_return{"@list"}    = $retval;
  } elsif( $cmd eq "SCORE" ) {
    $score_cmds{"@list"}    = "$covered $gflag score $cmd_list;";
    $score_output{"@list"}  = $output;
    $score_return{"@list"}  = $retval;
  } elsif( $cmd eq "MERGE" ) {
    $merge_cmds{"@list"}    = "$covered $gflag merge $cmd_list;";
    $merge_output{"@list"}  = $output;
    $merge_return{"@list"}  = $retval;
  } elsif( $cmd eq "REPORT" ) {
    $report_cmds{"@list"}   = "$covered $gflag report $cmd_list;";
    $report_output{"@list"} = $output;
    $report_return{"@list"} = $retval;
  } else {
    $run = 0;
  }

  return( $run );

}

sub parse_diag_header_line {

  my $line = $_[0];
  my $run;

  if( $line =~ /GROUPS(.*)/ ) {
    $run = &parse_groups( $1 );
  } else {
    $run = &parse_cmd( $line );
  }

  return( $run );

}

sub read_diag_info {

  my $diag_name = $_[0];
  my $run = 1;
  my $in_header, $in_output, $name;

  # Clear global variables
  @groups_to_run = ();
  %sim_cmds      = ();
  %sim_output    = ();
  %sim_return    = ();
  %score_cmds    = ();
  %score_output  = ();
  %score_return  = ();
  %merge_cmds    = ();
  %merge_output  = ();
  %merge_return  = ();
  %report_cmds   = ();
  %report_output = ();
  %report_return = ();

  open( DIAG, $diag_name ) || die "ERROR:  Unable to read diagnostic $diag_name: $!\n";

  while( ($line = <DIAG>) && ($run == 1) ) {
    chomp( $line );
    if( ($in_header == 0) && ($in_output == 0) ) {
      if( $line =~ /^\s*\/\*\s*HEADER/ ) {
        $in_header = 1;
      } elsif( $line =~ /^\s*\/\*\s*OUTPUT\s+(.*)/ ) {
        $name      = $1;
        $in_output = 1;
        open( OFILE, ">${name}.diag" );
      }
    } elsif( $line =~ /^\s*\*\// ) {
      if( $in_header == 1 ) {
        $in_header = 0;
      } elsif( $in_output == 1 ) {
        $in_output = 0;
        close( OFILE );
      }
    } elsif( $in_header == 1 ) {
      $run = &parse_diag_header_line( $line );
    } elsif( $in_output == 1 ) {
      print OFILE "$line\n";
    }
  }

  close( DIAG );

  return( $run );

}

sub prereqs_contain_a_minus {

  my @prereqs = split( /\s+/, $_[0] );
  my $prereq, $a_minus;

  $a_minus = 0;
  foreach $prereq (@prereqs) {
    if( $groups_minus{$prereq} ne "" ) {
      $a_minus = 1;
    }
  }

  return( $a_minus )

}

sub add_output_file {

  my ($diag_name, $outfile) = @_;
  my $line, $tmp;

  open( IFILE, "${diag_name}.v" ) || die "ERROR:  Unable to open ${diag_name}.v for reading: $!\n";
  open( OFILE, ">${diag_name}.v.new" ) || die "ERROR:  Unable to open ${diag_name}.v.new for writing: $!\n";

  while( $line = <IFILE> ) {
    chomp( $line );
    if( $line eq "EMPTY-${outfile}" ) {
      $tmp = `cat ${outfile}`;
      print OFILE $tmp;
    } else {
      print OFILE $line . "\n";
    }
  }

  close( OFILE );
  close( IFILE );

  system( "mv ${diag_name}.v.new ${diag_name}.v" ) && die;

}

sub run_current_diag {

  my $diag_name = $_[0];
  my $output_to_rm = "";
  my $prereqs, $prereq, $ran, %cmds, %output, %retval, $i;
  my $reason, $error, $failed;
  my $cmdline, %cmdlines, %cmdlines_to_run;
  my @prereq_list, $found_cmd, $cmd, $outfile, %output_files;

  $ran             = 0;
  $failed          = 0;
  $reason          = "";
  %cmdlines        = ();
  %cmdlines_to_run = ();
  %output_files    = ();

  # Initialize prerequisites with the specified groups to run
  $prereqs = join( " ", @groups_to_run );

  # Run diagnostic
  for( $i=0; $i<4; $i++ ) {

    if( $i == 0 ) {             # Compilation/simulation
      %cmds    = %sim_cmds;
      %output  = %sim_output;
      %retval  = %sim_return;
    } elsif( $i == 1 ) {        # Score
      %cmds    = %score_cmds;
      %output  = %score_output;
      %retval  = %score_return;
    } elsif( $i == 2 ) {        # Merge
      %cmds    = %merge_cmds;
      %output  = %merge_output;
      %retval  = %merge_return;
    } elsif( $i == 3 ) {        # Report
      %cmds    = %report_cmds;
      %output  = %report_output;
      %retval  = %report_return;
    }

    @prereq_list = split( /\s+/, $prereqs );

    foreach $prereq (@prereq_list) {
      foreach $cmd (keys( %cmds )) {
        if( (index( " ${cmd} ", " ${prereq} " ) != -1) && (&prereqs_contain_a_minus( $cmd ) == 0) ) {
          $found_cmd = 0;
          foreach $cmdline (keys( %cmdlines )) {
            if( (index( " $cmdlines{$cmdline} ", " $prereq ") != -1) && ($found == 0) ) {
              foreach $outfile (split( /\s+/, $output{$cmd} )) {
                if( $outfile ne "" ) {
                  $cmdlines{"$cmdline $cmds{$cmd}"}        = $outfile;
                  $cmdlines_to_run{"$cmdline $cmds{$cmd}"} = (($cmdlines_to_run{$cmdline} > 1) || ($retval{$cmd} > 0)) ? 2 : 1;
                  $output_files{"$cmdline $cmds{$cmd}"}    = "$output_files{$cmdline} $outfile";
                }
              }
              $cmdlines_to_run{$cmdline} = 0;
              $found_cmd = 1;
            }
          }
          if( $found_cmd == 0 ) {
            foreach $outfile (split( /\s+/, $output{$cmd} )) {
              if( $outfile ne "" ) {
                $cmdlines{$cmds{$cmd}}        = $outfile;
                $cmdlines_to_run{$cmds{$cmd}} = ($retval{$cmd} > 0) ? 2 : 1;
                $output_files{$cmds{$cmd}}    = $outfile;
              }
            }
          }
          $prereqs = join( " ", $prereqs, $output{$cmd} );
        }
      }
    }

  }

  if( keys( %cmdlines_to_run ) > 0 ) {
    print "Running ${diag_name}\n";
  }

  # Run each command-line
  foreach $cmdline (keys( %cmdlines_to_run )) {
    if( $cmdlines_to_run{$cmdline} > 0 ) {
      print "COMMAND: $cmdline\n";
      $error = system( "$cmdline" );
      $ran   = 1;
      if( (($cmdlines_to_run{$cmdline} == 1) && ($error == 0)) ||
          (($cmdlines_to_run{$cmdline} == 2) && ($error != 0)) ) {
        $error = 0;
        foreach $outfile (split( /\s+/, $output_files{$cmdline} )) {
          if( -e "$outfile.diag" ) {
            $error = system( "diff ${outfile} ${outfile}.diag" );
          }
          if( $error == 0 ) {
            system( "rm -f ${outfile}" );
          } else {
            if( -e "$outfile.diag" ) {
              $tmp = `cat $outfile.diag`;  chomp( $tmp );
              if( $tmp eq "EMPTY-${outfile}" ) {
                $reason = "UNTESTED DIAGNOSTIC";
                if( -e $outfile ) {
                  &add_output_file( $diag_name, $outfile );
                }
              } else {
                $reason = "diff ${outfile} ${outfile}.diag";
              }
            } else { 
              $reason = "diff ${outfile} ${outfile}.diag";
            }
            $failed = 1;
          }
        }
      } else {
        $failed = 1;
        $reason = $cmdline;
      }
    }
  }

  # Remove diagnostic output files if there were no errors
  if( $failed == 0 ) {
    foreach $outfiles (keys( %output_files )) {
      foreach $outfile (split( /\s+/, $output_files{$outfiles})) {
        system( "rm -f $outfile.diag" );
      }
    }
  }

  return( ($ran, $failed, $reason) );

}

sub run_diags {

  my $run, $diag_name, $ran, $failed, $failing_cmd;

  opendir( VDIR, "." );

  while( $file = readdir( VDIR ) ) {
    chomp( $file );
    if( $file =~ /(.*)\.v$/ ) {
      $diag_name = $1;
      $run = &read_diag_info( "$diag_name.v" );
      if( $run == 1 ) {
        ($ran, $failed, $failing_cmd) = &run_current_diag( $diag_name );
        if( $ran == 1 ) {
          if( $failed == 1 ) {
            print "  -- FAILED\n";
            $failed_diags[@failed_diags] = "$diag_name  ($failing_cmd)";
          } else {
            print "  -- PASSED\n";
            $passed_diags[@passed_diags] = $diag_name;
          }
        }
      }
    }
  }

  closedir( VDIR );

}

sub output_results {

  my $diag;

  print "\nPassed: " . @passed_diags . ", Failed: " . @failed_diags . "\n";

  if( @failed_diags > 0 ) {
    print "\n";
    print "Failing diagnostics:\n";
    foreach $diag (@failed_diags) {
      print "   $diag\n";
    }
  }

  print "\n";

}
