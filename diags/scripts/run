#!/usr/bin/perl

# Name:     run
# Author:   Trevor Williams  <trevorw(sgi.com)>
# Date:     2/11/2005
# Brief:    Script used for running both regressions and single diagnostics.
# Usage:    run <list_of_groups>

# Defines
$covered = "../../src/covered";

# Global variables
$gflag         = "-Q";
%groups_plus   = ();
%groups_minus  = ();
%groups_to_run = ();
%sim_cmds      = ();
%score_cmds    = ();
%score_output  = ();
%merge_cmds    = ();
%merge_output  = ();
%report_cmds   = ();
%report_output = ();
@passed_diags  = ();
@failed_diags  = ();
$merge_set     = 0;
$report_set    = 0;

if( $env{"COVERED_GFLAG"} ne "" ) {
  $gflag = $env{"COVERED_GFLAG"};
}

# Parse command-line arguments
&parse_args;

# Run diagnostics
&run_diags;

# Output the results
&output_results;

###################################################################3

sub parse_args {

  foreach $arg (@ARGV) {
    if( $arg =~ /^\+(.*)/ ) {
      $groups_plus{$1} = 1;
    } elsif( $arg =~ /^\-(.*)/ ) {
      $groups_minus{$1} = 1;
    } else {
      &usage;
    }
  }

}

sub usage {

  print "Usage:  run <list_of_groups>\n";
  die;

}

sub parse_groups {

  my @line = split( /\s+/, $_[0] );
  my $run  = 0;

  foreach $group (@line) {
    if( ($groups_plus{$group} eq "1") && ($groups_minus{$group} eq "") ) {
      $groups_to_run{$group} = 1;
      $run = 1;
    }
  }

  @groups = keys( %groups_to_run );
  $merge_cmds{" @groups "}  = "";
  $merge_set                = 0;
  $report_cmds{" @groups "} = "";
  $report_set               = 0;

  return( $run );

}

sub parse_cmd {

  my $line = $_[0];
  my $run, $cmd;
  my $prereq_list, $cmd_list, $output, @list;

  # Split line based on the colon character
  ($prereq_list,$cmd_list,$output) = split( /:/, $line );

  # Parse prerequisite list
  @list = split( /\s+/, $prereq_list );
  $run  = 1;
  $cmd  = shift( @list );

  if( $cmd eq "SIM" ) {
    $sim_cmds{" @list "}      = "$cmd_list;";
    $sim_output{"@list"}    = $output;
  } elsif( $cmd eq "SCORE" ) {
    $score_cmds{" @list "}    = "$covered $gflag score $cmd_list;";
    $score_output{"@list"}  = $output;
  } elsif( $cmd eq "MERGE" ) {
    $merge_cmds{" @list "}    = "$covered $gflag merge $cmd_list;";
    $merge_output{"@list"}  = $output;
  } elsif( $cmd eq "REPORT" ) {
    $report_cmds{" @list "}   = "$covered $gflag report $cmd_list;";
    $report_output{"@list"} = $output;
  } else {
    $run = 0;
  }

  return( $run );

}

sub parse_diag_header_line {

  my $line = $_[0];
  my $run;

  if( $line =~ /GROUPS(.*)/ ) {
    $run = &parse_groups( $1 );
  } else {
    $run = &parse_cmd( $line );
  }

  return( $run );

}

sub read_diag_info {

  my $diag_name = $_[0];
  my $run = 1;
  my $in_header, $in_output, $name;

  # Clear global variables
  %groups_to_run = ();
  %sim_cmds      = ();
  %score_cmds    = ();
  %score_output  = ();
  %merge_cmds    = ();
  %merge_output  = ();
  %report_cmds   = ();
  %report_output = ();

  open( DIAG, $diag_name ) || die "ERROR:  Unable to read diagnostic $diag_name: $!\n";

  while( ($line = <DIAG>) && ($run == 1) ) {
    chomp( $line );
    if( ($in_header == 0) && ($in_output == 0) ) {
      if( $line =~ /^\s*\/\*\s*HEADER/ ) {
        $in_header = 1;
      } elsif( $line =~ /^\s*\/\*\s*OUTPUT\s+(\w+)/ ) {
        $name      = $1;
        $in_output = 1;
        open( OFILE, ">${name}.diag" );
      }
    } elsif( $line =~ /^\s*\*\// ) {
      if( $in_header == 1 ) {
        $in_header = 0;
      } elsif( $in_output == 1 ) {
        $in_output = 0;
        close( OFILE );
      }
    } elsif( $in_header == 1 ) {
      $run = &parse_diag_header_line( $line );
    } elsif( $in_output == 1 ) {
      print OFILE "$line\n";
    }
  }

  close( DIAG );

  return( $run );

}

sub run_current_diag {

  my $diag_name = $_[0];
  my $group, $cmd, $error, $ran;
  my $sim, $score, $merge, $report;
  my %commands = ();

  $ran = 0;

  @prereqs = keys( %groups_to_run );

  $run = 0;
  foreach $sim (keys( %sim_cmds )) {
    foreach $prereq (@prereqs) {
    if( index( $sim, " ${prereq} " ) != -1 ) {
      $run = 1;
    }
  }
    if( $sim_cmds{$sim}
    foreach $prereq (keys( &prereqs )) {
      if( index( $sim, 

  # Put together all combinations of possible commands
  foreach $group (keys( %groups_to_run )) {
      foreach $sim (keys( %sim_cmds )) {
        if( (index( $sim, " ${group} " ) != -1) && (&contains_minus_group( $sim ) == 0) ) {
          foreach $score (keys( %score_cmds )) {
            if( (index( $score, " ${group} " ) != -1) && (&contains_minus_group( $score ) == 0) ) {
              foreach $merge (keys( %merge_cmds )) {
                if( (index( $merge, " ${group} " ) != -1) && (&contains_minus_group( $merge ) == 0) ) {
                  foreach $report (keys( %report_cmds )) {
                    if( (index( $report, " ${group} " ) != -1) && (&contains_minus_group( $report ) == 0) ) {
                      $cmd = "${sim_cmds{$sim}} ${score_cmds{$score}} ${merge_cmds{$merge}} ${report_cmds{$report}}";
                      if( $commands{$cmd} eq "" ) {
                        $commands{$cmd} = 1;
                        print "cmd: $cmd";
                        $error = system( "$cmd" );
                        if( ($error == 0) && ($score_output{$score} ne "") ) {
                          print "Checking for differences with ${score_output{$score}}\n";
                          $error = system( "diff ${score_output{$score}} ${score_output{$score}}.diag" );
                        }
                        if( ($error == 0) && ($merge_output{$merge} ne "") ) {
                          $error = system( "diff ${merge_output{$merge}} ${merge_output{$merge}}.diag" );
                        }
                        if( ($error == 0) && ($report_output{$merge} ne "") ) {
                          $error = system( "diff ${report_output{$report}} ${report_output{$report}}.diag" );
                        }
                        if( $error != 0 ) {
                          return( 1, 1, $cmd );
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  return( ($ran, 0, "") );

}

sub run_diags {

  my $run, $diag_name, $ran, $failed, $failing_cmd;

  opendir( VDIR, "." );

  while( $file = readdir( VDIR ) ) {
    chomp( $file );
    if( $file =~ /(.*)\.v$/ ) {
      $diag_name = $1;
      $run = &read_diag_info( "$diag_name.v" );
      if( $run == 1 ) {
        ($ran, $failed, $failing_cmd) = &run_current_diag( "$diag_name.v" );
        if( $ran == 1 ) {
          if( $failed == 1 ) {
            $failed_diags[@failed_diags] = "$diag_name  $failing_cmd";
          } else {
            $passed_diags[@passed_diags] = $diag_name;
          }
        }
      }
    }
  }

  closedir( VDIR );

}

sub output_results {

  my $diag;

  print "\nPassed: " . @passed_diags . ", Failed: " . @failed_diags . "\n";

  if( @failed_diags > 0 ) {
    print "\n";
    print "Failing diagnostics:\n";
    foreach $diag (@failed_diags) {
      print "   $diag\n";
    }
  }

  print "\n";

}
