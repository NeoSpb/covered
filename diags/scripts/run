#!/usr/bin/perl

# Name:     run
# Author:   Trevor Williams  <trevorw(sgi.com)>
# Date:     2/11/2005
# Brief:    Script used for running both regressions and single diagnostics.
# Usage:    run <list_of_groups>

# Defines
$covered = "../../src/covered";

# Global variables
$gflag         = "-Q";
%groups_plus   = ();
%groups_minus  = ();
%groups_to_run = ();
%comp_cmds     = ();
%sim_cmds      = ();
%score_cmds    = ();
%score_output  = ();
%merge_cmds    = ();
%merge_output  = ();
%report_cmds   = ();
%report_output = ();
@passed_diags  = ();
@failed_diags  = ();
$merge_set     = 0;
$report_set    = 0;

if( $env{"COVERED_GFLAG"} ne "" ) {
  $gflag = $env{"COVERED_GFLAG"};
}

# Parse command-line arguments
&parse_args;

# Run diagnostics
&run_diags;

# Output the results
&output_results;

###################################################################3

sub parse_args {

  foreach $arg (@ARGV) {
    if( $arg =~ /^\+(.*)/ ) {
      $groups_plus{$1} = 1;
    } elsif( $arg =~ /^\-(.*)/ ) {
      $groups_minus{$1} = 1;
    } else {
      &usage;
    }
  }

}

sub usage {

  print "Usage:  run <list_of_groups>\n";
  die;

}

sub parse_groups {

  my @line = split( /\s+/, $_[0] );
  my $run  = 0;

  foreach $group (@line) {
    if( ($groups_plus{$group} eq "1") && ($groups_minus{$group} eq "") ) {
      $groups_to_run{$group} = 1;
      $run = 1;
    }
  }

  @groups = keys( %groups_to_run );
  $merge_cmds{" @groups "}  = "";
  $merge_set                = 0;
  $report_cmds{" @groups "} = "";
  $report_set               = 0;

  return( $run );

}

sub parse_cmd {

  my $line = $_[0];
  my $run, $cmd;
  my $group_list, $cmd_list, $output, @list;

  # Split line based on the colon character
  ($group_list,$cmd_list,$output) = split( /:/, $line );

  # Parse group list
  @list = split( /\s+/, $group_list );
  $run  = 1;
  $cmd  = shift( @list );

  if( $cmd eq "COMP" ) {
    $comp_cmds{" @list "}     = "$cmd_list;";
  } elsif( $cmd eq "SIM" ) {
    $sim_cmds{" @list "}      = "$cmd_list;";
  } elsif( $cmd eq "SCORE" ) {
    $score_cmds{" @list "}    = "$covered $gflags score $cmd_list;";
    $score_output{" @list "}  = $output;
  } elsif( $cmd eq "MERGE" ) {
    if( $merge_set == 0 ) {
      %merge_cmds = ();
      $merge_set  = 1;
    }
    $merge_cmds{" @list "}    = "$covered $gflags merge $cmd_list;";
    $merge_output{" @list "}  = $output;
  } elsif( $cmd eq "REPORT" ) {
    if( $report_set == 0 ) {
      %report_cmds = ();
      $report_set  = 1;
    }
    $report_cmds{" @list "}   = "$covered $gflags report $cmd_list;";
    $report_output{" @list "} = $output;
  } else {
    $run = 0;
  }

  return( $run );

}

sub parse_diag_header_line {

  my $line = $_[0];
  my $run;

  if( $line =~ /GROUPS(.*)/ ) {
    $run = &parse_groups( $1 );
  } else {
    $run = &parse_cmd( $line );
  }

  return( $run );

}

sub read_diag_info {

  my $diag_name = $_[0];
  my $run = 1;
  my $in_header, $in_output, $name;

  # Clear global variables
  %groups_to_run = ();
  %comp_cmds     = ();
  %sim_cmds      = ();
  %score_cmds    = ();
  %score_output  = ();
  %merge_cmds    = ();
  %merge_output  = ();
  %report_cmds   = ();
  %report_output = ();

  open( DIAG, $diag_name ) || die "ERROR:  Unable to read diagnostic $diag_name: $!\n";

  while( ($line = <DIAG>) && ($run == 1) ) {
    chomp( $line );
    if( ($in_header == 0) && ($in_output == 0) ) {
      if( $line =~ /^\s*\/\*\s*HEADER/ ) {
        $in_header = 1;
      } elsif( $line =~ /^\s*\/\*\s*OUTPUT\s+(\w+)/ ) {
        $name      = $1;
        $in_output = 1;
        open( OFILE, ">${name}.diag" );
      }
    } elsif( $line =~ /^\s*\*\// ) {
      if( $in_header == 1 ) {
        $in_header = 0;
      } elsif( $in_output == 1 ) {
        $in_output = 0;
        close( OFILE );
      }
    } elsif( $in_header == 1 ) {
      $run = &parse_diag_header_line( $line );
    } elsif( $in_output == 1 ) {
      print OFILE "$line\n";
    }
  }

  close( DIAG );

  return( $run );

}

sub contains_minus_group {

  my $key = $_[0];
  my $group, $retval;

  $retval = 0;

  foreach $group (keys( %groups_minus )) {
    if( index( $key, " ${group} " ) != -1 ) {
      $retval = 1;
    }
  }

  print "key ${key} contains a minus group\n";

  return( $retval );

}

sub run_current_diag {

  my $diag_name = $_[0];
  my $group, $cmd, $error, $ran;
  my $comp, $sim, $score, $merge, $report;
  my %commands = ();

  $ran = 0;

  if( keys( %groups_to_run ) > 0 ) {

    $ran = 1;
    print "Running $diag_name\n";

    # Put together all combinations of possible commands
    foreach $group (keys( %groups_to_run )) {
      foreach $comp (keys( %comp_cmds )) {
        if( (index( $comp, " ${group} " ) != -1) && (&contains_minus_group( $comp ) == 0) ) {
          foreach $sim (keys( %sim_cmds )) {
            if( (index( $sim, " ${group} " ) != -1) && (&contains_minus_group( $sim ) == 0) ) {
              foreach $score (keys( %score_cmds )) {
                if( (index( $score, " ${group} " ) != -1) && (&contains_minus_group( $score ) == 0) ) {
                  foreach $merge (keys( %merge_cmds )) {
                    if( (index( $merge, " ${group} " ) != -1) && (&contains_minus_group( $merge ) == 0) ) {
                      foreach $report (keys( %report_cmds )) {
                        if( (index( $report, " ${group} " ) != -1) && (&contains_minus_group( $report ) == 0) ) {
                          $cmd = "${comp_cmds{$comp}} ${sim_cmds{$sim}} ${score_cmds{$score}} ${merge_cmds{$merge}} ${report_cmds{$report}}";
                          print "cmd: $cmd";
                          if( $commands{$cmd} eq "" ) {
                            $commands{$cmd} = 1;
                            $error = system( "$cmd" );
                            if( ($error == 0) && ($score_output{$score} ne "") ) {
                              $error = system( "diff ${score_output{$score}} ${score_output{$score}}.diag" );
                            }
                            if( ($error == 0) && ($merge_output{$merge} ne "") ) {
                              $error = system( "diff ${merge_output{$merge}} ${merge_output{$merge}}.diag" );
                            }
                            if( ($error == 0) && ($report_output{$merge} ne "") ) {
                              $error = system( "diff ${report_output{$report}} ${report_output{$report}}.diag" );
                            }
                            if( $error != 0 ) {
                              return( 1, 1, $cmd );
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

  }

  return( ($ran, 0, "") );

}

sub run_diags {

  my $run, $diag_name, $ran, $failed, $failing_cmd;

  opendir( VDIR, "." );

  while( $file = readdir( VDIR ) ) {
    chomp( $file );
    if( $file =~ /(.*)\.v/ ) {
      $diag_name = $1;
      $run = &read_diag_info( "$diag_name.v" );
      if( $run == 1 ) {
        ($ran, $failed, $failing_cmd) = &run_current_diag( "$diag_name.v" );
        if( $ran == 1 ) {
          if( $failed == 1 ) {
            $failed_diags[@failed_diags] = "$diag_name  $failing_cmd";
          } else {
            $passed_diags[@passed_diags] = $diag_name;
          }
        }
      }
    }
  }

  closedir( VDIR );

}

sub output_results {

  my $diag;

  print "\nPassed: " . @passed_diags . ", Failed: " . @failed_diags . "\n";

  if( @failed_diags > 0 ) {
    print "\n";
    print "Failing diagnostics:\n";
    foreach $diag (@failed_diags) {
      print "   $diag\n";
    }
  }

  print "\n";

}
