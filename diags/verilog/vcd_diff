#!/usr/bin/perl

# Name:         vcd_diff
# Author:       Trevor Williams  (phase1geo at gmail.com)
# Date:         7/5/2009
# Description:  Compares two VCD files removing Covered inlined coverage signals and glitches.
# Usage:        vcd_diff <VCD filename> <VCD filename>

$VNAME1 = $ARGV[0];
$VNAME2 = $ARGV[1];

if( ($VNAME1 eq "") || ($VNAME2 eq "") ) {
  &usage;
}

# Open both files for reading
open( VFILE1, "$VNAME1" ) || die "Can't open $VNAME1 for reading: $!\n";
open( VFILE2, "$VNAME2" ) || die "Can't open $VNAME2 for reading: $!\n";

# Read in the header information from both VCD files
&vcd_parse_def( 0 );
&vcd_parse_def( 1 );

# Verify differences
&vcd_diff_header;

while( ($timestep1 != -1) && ($timestep2 != -1) ) {
  &vcd_parse_sim( 0 );
  &vcd_parse_sim( 1 );
}

close( VFILE1 );
close( VFILE2 );

######  End of Main Subroutine  ######

sub usage {

  print "Usage:  vcd_diff <VCD filename> <VCD filename>\n";
  die;

}

sub vcd_parse_def_var {

  my( $num, $str ) = $@;
  my $type;
  my $size;
  my $id_code;
  my $ref;
  my $reftmp;
  my $tmp[15];
  my $msb = -1;
  my $lsb = -1;
  my $tmplsb;

  if( $str ~= /\s*(\w+)\s+(\d+)\s+(\w+)\s+(\w+)\s+(\w+)/ ) {

    $type    = $1;
    $size    = $2;
    $id_code = $3;
    $ref     = $4;
    $tmp     = $5;

    if( $type eq "real" ) {

      $msb = 63;
      $lsb = 0;

    } else {

      if( $tmp ne "$end" ) {

        /* A bit select was specified for this signal, get the size */
        if( $tmp ~= /\[(\d+):(\d+)\]/ ) {
          $msb = $1;
          $lsb = $2;
        } elseif( $tmp ~= /\[(\d+)\]/ ) {
          $lsb = $1;
          $msb = $lsb;
        } else {
          die "ERROR:  Unrecognized $var format\n";
        }

        if( (fscanf( vcd, "%s", tmp ) != 1) || (strncmp( "$end", tmp, 4 ) != 0) ) {
          print_output( "Unrecognized $var format", FATAL, __FILE__, __LINE__ );
          Throw 0;
        }

      } elseif( $ref ~= /([a-zA-Z0-9_]+)\[(\w+)\]\./ ) {

        $reftmp = $1;
        $tmp    = $2;

        # This is a hierarchical reference so we shouldn't modify ref -- quirky behavior from VCS
        msb = size - 1;
        lsb = 0;

      } elseif( $ref ~= /([a-zA-Z0-9_]+)\[(\w+)\]/ ) {

        $reftmp = $1;
        $tmp    = $2;
        $ref    = $reftmp;

        if( $tmp ~= /(\d+):(\d+)/ ) {
          $msb = $1;
          $lsb = $2;
        } elseif( $tmp ~= /(\d+)/ ) {
          $lsb = $1;
          $msb = $lsb;
        } else {
          die "ERROR:  Unrecognized $var format\n";
        }

      } else {

        $msb = $size - 1;
        $lsb = 0;

      }

    }     
            
    # Store the signal
    $db->{$num}{SCOPES}{$curr_scope}{SIGNALS}{$ref}{ID}  = $id_code;
    $db->{$num}{SCOPES}{$curr_scope}{SIGNALS}{$ref}{MSB} = $msb;
    $db->{$num}{SCOPES}{$curr_scope}{SIGNALS}{$ref}{LSB} = $lsb;
    $db->{$num}{IDS}{$id_code}                           = $ref;
        
  } else {
        
    die "ERROR:  Unrecognized $var format\n";
        
  }
      
}
        
# Parses definition $scope keyword line until $end keyword is seen.
sub vcd_parse_def_scope {
            
  my( $num, $str ) = @_;
  my $type;
  my $id;
          
  if( $str ~= /\s*(\w+)\s+(\w+)\s+\$end/ ) {

    $type = $1;
    $id   = $2;
        
    # For now we will let any type slide
    $db->{$num}{PARENT}{"$curr_scope$id"} = $curr_scope;

    # Update current scope
    $curr_scope .= $id;

  } else {

    die "ERROR:  Unrecognized $scope format\n";

  }

  PROFILE_END;

}

sub vcd_parse_def {
  
  my $num          = $_[0];
  my $enddef_found = 0;
  my $keyword, $line;
  my $chars_read;

  while( !enddef_found && ((($num == 0) && ($line = <VFILE1>)) || (($num == 1) && ($line = <VFILE2>))) ) {

    chomp( $line );
    ($keyword, $line) = split( $line );

    if( substr( $keyword, 0, 1 ) eq "$" ) {

      if( substr( $keyword, 1 ) eq "var" ) {
        &vcd_parse_def_var( $num, $line );
      } elseif( substr( $keyword, 1 ) eq "scope" ) {
        &vcd_parse_def_scope( vcd, $line );
      } elseif( substr( $keyword, 1 ) eq "upscope" ) {
        $curr_scope = $db->{$num}{PARENT}{$curr_scope};
      } elseif( substr( $keyword, 1 ) eq "enddefinitions" ) {
        enddef_found = 1;
      }

    } else {

      die "ERROR:  Non-keyword located where one should have been \"$keyword\"\n";

    }

  }

}

sub vcd_diff_header {

  # First, compare the first database against the second
  foreach $scope (keywords %db->{0}{SCOPES}) {
    if( keywords( %db->{1}{SCOPES}{$scope} ) ne "" ) {
      $db->{1}{SCOPES}{$scope}{MATCHED} = 1;
    } else {
      die "ERROR:  Scope $scope not found in second database\n";
    }
    foreach $signal (keywords %db->{0}{SCOPES}{$scope}{SIGNALS}) {
      if( ($db->{0}{SCOPES}{$scope}{SIGNALS}{$signal}{MSB} ne $db->{1}{SCOPES}{$scope}{SIGNALS}{$signal}{MSB}) ||
          ($db->{0}{SCOPES}{$scope}{SIGNALS}{$signal}{LSB} ne $db->{1}{SCOPES}{$scope}{SIGNALS}{$signal}{LSB}) ) {
        $db->{1}{SCOPES}{$scope}{SIGNALS}{$signal}{MATCHED} = 1;
      } else {
        die "ERROR:  Signal $scope.$signal not found in second database\n";
      }
    }
  }

  # Second, scroll through the second database to see if there are any unmatched things
  foreach $scope (keywords %db->{1}{SCOPES}) {
    if( $db->{1}{SCOPES}{$scope}{MATCHED} == 0 ) {
      die "ERROR:  Scope $scope not found in first database\n";
    }
    foreach $signal (keywords %db->{1}{SCOPES}{$scope}{SIGNALS}) {
      if( $db->{1}{SCOPES}{$scope}{SIGNALS}{$signal}{MATCHED} == 0 ) {
        die "ERROR:  Signal $scope.$signal not found in first database\n";
      }
    }
  }

}

sub vcd_diff_timestep {

  my $timestep = $_[0];

  

}

sub vcd_parse_sim {

  my $num           = @_;
  my $token;
  my $last_timestep = 0;
  my $carry_over    = 0;
  my $simulate      = 1;

  while( (($num == 0) && ($line = <VFILE1)) || (($num == 1) && ($line = <VFILE2>)) && $simulate ) {

    if( $line[0] == '$' ) {

      /* Ignore */

    } elsif( (substr( $line, 0, 1 ) eq "b") || (substr( $line, 0, 1 ) eq "B") ) {

      &vcd_parse_sim_vector( $num, substr( $line, 1 ) );

    } else if( (substr( $line, 0, 1 ) eq "r") || (substr( $line, 0, 1 ) eq "R") || $carry_over ) {

      &vcd_parse_sim_real( $num, substr( $line, 1 ) );
      $carry_over = 0;

    } else if( substr( $line, 0, 1 ) eq "#" ) {

      $simulate      = 0;
      $last_timestep = substr( $line, 1 );
      &vcd_diff_timestep( $last_timestep );

    } else if( (substr( $line, 0, 1 ) eq "0") ||
               (substr( $line, 0, 1 ) eq "1") ||
               (substr( $line, 0, 1 ) eq "x") ||
               (substr( $line, 0, 1 ) eq "X") ||
               (substr( $line, 0, 1 ) eq "z") ||
               (substr( $line, 0, 1 ) eq "Z") ) {

      &db_set_symbol_char( $num, substrtoken + 1, token[0] );

    } else {

      die "ERROR:  Badly placed token \"$line\"\n";

    }

  }

  # Simulate the last timestep now
  if( $simulate ) {
    &vcd_diff_timestep( $last_timestep );
  }

  PROFILE_END;

}

sub vcd_parse_sim_timestep {

  my( $num ) = $_[0];

}

