<!--
[variables]
{
  $page_title = "Reading Combinational Logic Coverage"
  $page_title_english = "Reading Combinational Logic Coverage"
  $file_prev = "019.html"
  $file_next = "021.html"
  $real_page_number = "20"
  $page_number = "20"
}
-->

<_header2>
$page_title
</_header2>

<_header3>
Summary Information Description - Module-based
</_header3>

<_pg>
For module-based reports, the summary table for combinational logic metrics includes
information for the name of each module that was covered and the name of the file in which
the module is described in.  Lines <a href="example.rptM.html#60">60 through 66</a> of the
module-based report show what this information looks like in the report.  We have two
modules that were scored within our DUT:  main and foobar.  The table shows that both
modules were described in the file "example.v".
</_pg>

<_header3>
Summary Information Description - Instance-based
</_header3>

<_pg>
For instance-based reports, the summary table for combinational logic metrics includes
information for the Verilog hierarchy pertaining to each instance on the left-hand-side of
each row.  Lines <a href="example.rptI.html#66">66 through 72</a> of the instance-based report
show what this information looks like in the report.  In our DUT example, there are two
instances within the design with the Verilog hierarchies of "main" and "main.bar".
</_pg>

<_header3>
Summary Information Description - Both
</_header3>

<_pg>
On the right-hand side of each row in the table are the hit, miss and total numbers for the
combinational logic coverage, followed by a calculated percent of the combinational logic
expression values that were hit (calculated by taking the number of combinational logic
expression values hit during simulation divided by the total number of expression values
that Covered could have simulated).  The hit value indicates how many expression values
were achieved during the simulation; the miss value indicates the number of expression
values not achieved during simulation; and the total value indicates the total number of 
combinational logic expression values that could have been achieved in the specified
module/instance.
</_pg>

<_pg>
If the percentage value in the far left of the summary table is 100%, this indicates that
all combinational logic expression values that Covered was capable of achieving (for the
module/instance of this row) were hit.  If the value of the percentage is less than 100%,
this indicates that some number of expression values were not achieved and full coverage
was not achieved for that module/instance.  Note that for a module/instance which does not
contain any combinational logic expressions in which Covered was able to simulate, the
values of hit, miss, and total will be 0 while the hit percentage value will indicate 100%.
</_pg>

<_header3>
Verbose Information Description - Both
</_header3>

<_pg>
The verbose output for combinational coverage is a bit more sophisticated than the line or
toggle.  Basically, for each expression that was found to not be fully covered (either the
expression itself or some sub-expression in the tree was not fully covered), the expression
is output with various sub-expressions underlined and identified with a number.  Each
expression is also supplied with the line number that the expression started at in its module
file.  In our example, there is one expression in the module called "main" (see
lines <a href="example.rptM.html#74">74 through 77</a> and one expression in the module called
"foobar" (see lines <a href="example.rptM.html#112">112 through 113</a>.
</_pg>

<_pg>
Below each expression, there will be one or more tables which specify a particular
sub-expression that was not fully covered along with information describing what cases were
not covered for that sub-expression.
</_pg>

<_pg>
In the report output above, we see that there was one expression that did not have 100%
coverage on it and its subexpressions that starts on line 6 of the Verilog source.  The
expression is output to the report with certain sub-expressions underlined and labeled with
an integer value for reference.
</_pg>

<_pg>
For this one expression, there were found to be four subexpressions (labeled 1, 2, 6, 7) that
were found to not be 100% covered.  Taking a look at subexpression 1 report output, the
numbers to the right of the string "Expression 1" tell us the number of values of this
subexpression that were hit (in this case 1 value was hit) and the total number of values
that this subexpression can have (in this case 2 values were achievable).  The character
string below this information tells us the type of subexpression that we are examining.
For subexpression 1, the type is the unary NOT operator (~).
</_pg>

<_pg>
The table below this information for subexpression 1, lists the potential values that this
subexpression could have reached with a '*' character placed underneath the value(s) that was
missed.  In the case of subexpression 1, the value of 0 was not hit (meaning that the value
of the register b was never assigned the value of 1).  The letter 'E' above each possible
value indicates that this subexpression is a unary expression (its value comes from one
variable) and 'E' represents this subexpression's value (not the value of its subexpressions).
</_pg>
