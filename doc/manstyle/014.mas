<!--
[variables]
{
  $page_title = "The report Command"
  $page_title_english = "The report Command"
  $file_prev = "013.html"
  $file_next = "015.html"
  $real_page_number = "14"
  $page_number = "14"
}
-->

<_header1>
$page_title
</_header1>

<_pg>

</_pg>

<_header2>
Usage
</_header2>

<_pg>
The report command is initiated with the following call:
</_pg>

<_code>
covered report [&lt;options&gt;] &lt;CDD_filename&gt;
</_code>

<_pg>
The <i>CDD_filename</i> refers to the name of the CDD to
generate the report for.  This CDD may be either the result of
a score or the result of merging CDDs.
</_pg>

<_header2>
Options
</_header2>

<_pg>
The following table lists the options available for use with
the report command.
</_pg>

<_block>
<table cellspacing=2 cellpadding=4 border=1>
  <tr>
    <td colspan=2 class="tableHeader">
      Options to report Command
    </td>
  </tr>
  <tr>
    <td>
      <strong>Option</strong>
    </td>
    <td>
      <strong>Description</strong>
    <td>
  </tr>
  <tr>
    <td>
      -m [l][t][c][f]
    </td>
    <td>
      Specifies type of coverage information to report (default
is to generate report for line, toggle and combinational coverage).
    </td>
  </tr>
  <tr>
    <td>
      -d (s|d|v)
    </td>
    <td>
      Level of report detail (s=summary, d=detailed, v=verbose).
      Default is to display summary coverage information.
    </td>
  </tr>
  <tr>
    <td>
      -i
    </td>
    <td>
      Generates report information for each instance (default
is to generate per module).
    </td>
  </tr>
  <tr>
    <td>
      -c
    </td>
    <td>
      Used in conjunction with the '-d d' or '-d v' option.  If set, causes
covered logic to be reported instead of default behavior of
reporting uncovered logic.
  <tr>
    <td>
      -o &lt;<i>filename</i>&gt;
    </td>
    <td>
      Specifies output file to stream report to (default is
standard output)
    </td>
  </tr>
  <tr>
    <td>
      -h
    </td>
    <td>
      Outputs usage information for the merge command
    </td>
  </tr>
</table><br>
</_block>

<_header2>
Summary Vs. Detailed Vs. Verbose
</_header2>

<_pg>
There are three forms of reports that can be generated by the
Covered report function:  summary, detailed, and verbose.  The three forms
are described below.
</_pg>

<_header3>
Summary Report
</_header3>

<_pg>
A summary report shows at a very high-level what the coverage
for a specific module (or instance) is in terms of line, toggle, 
combinational and/or FSM coverage (depending on which types 
are selected on the command line).  Each coverage metric for
the module is given a percentage of items covered for that 
metric as well as the total number of items per metric, the
number of items "hit" during simulation and the number of
items "missed" during execution.  Each metric summary result
is output in the following format:
</_pg>

<_margin>Summary format</_margin>

<_pg>
&lt;<i>number_hit</i>&gt;/&lt;<i>number_missed</i>&gt;/&lt;<i>total_number</i>&gt; $sp$sp$sp&lt;<i>percent_hit</i>&gt;%
</_pg>

<_pg>
The summary report is useful for understanding exactly which
modules are missing coverage (and what type(s) of coverage
are missing) as well as what modules are fully covered.  This
can help guide you more easily in understanding where you need
to improve your code coverage without getting lost in all of 
the details that the verbose reporting provides.
</_pg>

<_header3>
Detailed Report
</_header3>

<_pg>
The detailed report is useful for understanding where logic was
found to be uncovered in the design along with some higher-level
information to understand why it was considered to be uncovered.
This amount of detail is between the minimum (summary coverage)
and the maximum (verbose coverage) and should be used as the first
detailed report to be looked at since it is easier to read and
comprehend the coverage results.
</_pg>

<_header3>
Verbose Report
</_header3>

<_pg>
The verbose report contains all of the data that the summary
report contains; however, in addition to the summary information
for a module (or instance), a more in-depth look at the exact
cases that were "missed" during simulation are provided.  The
format of the verbose information is specific to each coverage
metric but is summarized below.
</_pg>

<_header4>
Verbose Line Coverage Format
</_header4>

<_pg>
The verbose output for line coverage is quite simple.  Specifically,
the line number of the module that was missed during simulation
is output along with the Verilog code contained on that particular
line.  Only the missed cases are currently output in the verbose
report.  The following is the output format for line coverage:
</_pg>

<_margin>Line format</_margin>

<_pg>
&lt;<i>line_number</i>&gt;:$sp$sp$sp &lt;<i>verilog_code</i>&gt;
</_pg>

<_header4>
Verbose Toggle Coverage Format
</_header4>

<_pg>
The verbose output for toggle coverage is also simple.  Specifically,
the name of the signal that was not completely toggled along with
the bits that were toggled from 0 to 1 and 1 to 0.  The
format below shows the format for toggle coverage output.
</_pg>

<_margin>Toggle format</_margin>

<_pg>
&lt;<i>signal_name</i>&gt;:$sp$sp$sp &lt;<i>toggle_0->1_vector</i>&gt;$sp$sp$sp &lt;<i>toggle_1->0_vector</i>&gt;
</_pg>

<_pg>
It is important to remember that a 1 in a toggle vector indicates
that this bit was toggled during simulation; therefore, any bits
that are set to a value of 0 are bits that should be examined
to see why they were not fully toggled during simulation.
</_pg>

<_header4>
Verbose Combinational Coverage Format
</_header4>

<_pg>
The verbose output for combinational coverage is a bit more
sophisticated than the line or toggle.  Basically, for each
expression that was found to not be fully covered (some
sub-expression in the tree was not fully covered), the expression
is output with any sub-expressions that were not fully covered
being underlined with a value assigned to that expression.  The
value that is assigned is used to reference one of the tables
below the expression that show what cases were not covered
during simulation.  Each expression is also supplied with the
line number that the expression started at in its module file.
</_pg>

<_pg>
Below each expression, there will be one or more tables (one
for each underlined subexpression).  Each table will contain
two or three columns.  If the associated subexpression contained
only one variable, the table will be a two-column table.  The left
column will contain the value(s) that were not assigned to the
variable during simulation.  The right column represents the value
of performing the subexpression operation on the variable.
</_pg>

<_pg>
If the associated subexpression contained two variables, the 
table will be a three-column table.  The first two columns on
the left show all of the combinations of these two variables
that were not assigned to these variables during simulation.
The right-most column indicates the resulting output of
performing the subexpression operation on the two variables if
these values would have been assigned.
</_pg>

<_header4>
Verbose FSM Coverage Format
</_header4>

<_pg>
At the current time, FSM coverage reporting is not available
and the output for this coverage metric has not been determined.
</_pg>

<_header2>
Module Vs. Instance
</_header2>

<_pg>
Any report can be calculated by module or by instance.  Both
reports are of interest for verification purposes and the differences
are described as follows.
</_pg>

<_pg>
Module reporting combines the results of all instances that
come from the same module.  That is, when a module is instantiated
multiple times in a design, the coverage results from all
covered instances are merged together and output as one combined
module.  This reporting format allows a test writer to see if
any logic within a module has not been touched during simulation.
</_pg>

<_pg>
Instance reporting displays each instance in the covered design
separately (no combining occurs).  This reporting format is
useful for determining if certain instances within a design
are being neglected.  For instance, if a module is instantiated
four times (i.e., four instances of the same buffer), it may
be that the first buffer is used more often than the other
three buffers.  This could indicate controller errors or just
an indication that there was not enough activity during simulation
to fill the other buffers (need to bolster diagnostics or 
possibly some buffers could be removed?)  This type of information
would not be viewable if only module reporting were
performed.
</_pg>

<_header2>
Covered Vs. Uncovered
</_header2>

<_pg>
Covered has the ability the generate reports from any given CDD file
that displays either uncovered logic (the default behavior) or covered
logic.  It is understandable why one would want to generate reports
displaying uncovered logic (this is probably the reason why you are
interested in this tool in the first place).  However, why would anyone
be interested in reporting covered logic?
</_pg>

<_pg>
The reason for having this option is two-fold (and maybe there are other
reasons).  First, this option is useful in debugging the report command
since it let't the user evaluate whether a particular signal or portion
of logic was actually fully covered or not.  Second, it may be useful for
user's of the tool to understand what logic is being evaluated for
coverage and what logic is not.  If only uncovered logic was supplied for
evaluation of the tool, one could not evaluate the effectiveness of the
tool.  However, by allowing the user to see what logic is covered and
uncovered, a more full picture of the tool's capability can be understood.
</_pg>

<_pg>
To generate a report that specifies what logic is not covered (output only
available in verbose reporting mode), no further options are needed.  To
generate a report that specifies what logic is being covered, simply specify
the -c option along with the -v option when calling the report command.
</_pg>
