<!--
[variables]
{
  $page_title = "Reading the Report"
  $page_title_english = "Reading the Report"
  $file_prev = "015.html"
  $file_next = "017.html"
  $real_page_number = "16"
  $page_number = "16"
}
-->

<_header1>
$page_title
</_header1>

<_pg>

</_pg>

<_pg>
This chapter describes the meanings of the textual report output that Covered generates
when the report command is issued.  It is well understood by the developers of Covered that
a code coverage tool is only as good as the output that it generates, and this, of course,
includes the ability to discern the information provided by the report.
</_pg>

<_pg>
To help describe the various sections of a Covered report, we will use a relatively small
Verilog file containing our DUT, generating the two main types of reports (module and
instance) based on the CDD generated for this file.  This example file is provided 
<a href="test.v.html">here</a>.
</_pg>

<_pg>
After being compiled and run, this module is scored with the following Covered command:
</_pg>

<_margin>Score Command</_margin>

<_code>
covered score -t main -v test.v -o test.cdd -vcd test.vcd
</_code>

<_pg>
The module-based verbose report can be viewed in its entirety
<a href="test.rptM.html">here</a> and is generated with the following command:
</_pg>

<_margin>Module-base report command</_margin>

<_code>
covered report -d v test.cdd
</_code>

<_pg>
The instance-based verbose report can be viewed in its entirety
<a href="test.rptI.html">here</a> and is generated with the following command:
</_pg>

<_margin>Instance-based report command</_margin>

<_code>
covered report -i -d v test.cdd
</_code>

<_header2>
Line Coverage
</_header2>

<_header3>
Summary Information Description - Module-based
</_header3>

<_pg>
For module-based reports, the summary table for line metrics includes information for the
name of each module that was covered and the name of the file in which the module is
described in.  Lines <a href="test.rptM.html#4">4 through 9</a> of the module-based report
show what this information looks like in the report.  We have two modules that were scored
within our DUT:  main and foobar.  The table shows that both modules were described in the
file "test.v".
</_pg>

<_header3>
Summary Information Description - Instance-based
</_header3>

<_pg>
For instance-based reports, the summary table for line metrics includes information for
the Verilog hierarchy pertaining to each instance on the left-hand-side of each row.  Lines
<a href="test.rptI.html#4">4 through 9</a> of the instance-based report show what this
information looks like in the report.  In our DUT example, there are two instances within the
design with the Verilog hierarchies of "main" and "main.bar".
</_pg>

<_header3>
Summary Information Description - Both
</_header3>

<_pg>
On the right-hand side of each row in the table are the hit, miss and total numbers for the
line coverage, followed by a calculated percent of the lines that were hit (calculated by
taking the number of lines hit during simulation divided by the total number of lines that
Covered simulated).  The hit value indicates how many lines were executed during the
simulation; the miss value indicates the number of lines not executed during simulation; and
the total value indicates the total number of lines within the specified module/instance
that Covered was able to simulate.
</_pg>

<_pg>
If the percentage value in the far left of the summary table is 100%, this indicates that all
lines that Covered was capable of simulating (for the module/instance of this row) were
executed.  If the value of the percentage is less than 100%, this indicates that some number
of lines were not executed and full coverage was not achieved for that module/instance.  Note
that for a module/instance which does not contain any lines in which Covered was able to
simulate, the values of hit, miss, and total will be 0 while the hit percentage value will
indicate 100%.
</_pg>

<_header3>
Verbose Information Description - Both
</_header3>

<_pg>
If the miss value for a particular module was not 0 (indicating that lines were missed during
simulation) and the '-d v' option was specified on the command-line (specifying to output
verbose reporting information), the line that was missed during simulation will be output
below the summary information per module that contained missed lines.  In our sample report,
there was one line that was missed during simulation (according to the summary output) for
the module/instance called 'main'.  The line number and Verilog line that was missed is
output in lines <a href="test.rptM.html#11">11 through 16</a> of the module-based report
and in lines <a href="test.rptI.html#11">11 through 22</a> of the instance-based report.
</_pg>

<_pg>
If a module does not contain any missed lines and the '-d v' option was specified, no verbose
output will be displayed for this module.  Likewise, if a module/instance does not contain
any lines that Covered could execute, no verbose output will be displayed.
</_pg>

<_header4>
Important Note
</_header4>

<_pg>
The definition of what Covered considers a line is an expression (ex. assignment, conditional, 
etc.).  If an expression is written in such a way that it consumes multiple file lines, 
Covered only counts the expression as one line.  The user can assume that if the beginning
of an expression is labeled as missed, the entire expression was missed (not just the first
line of the expression).  For example, consider the following code:
</_pg>

<_code>
always @(posedge b)<br>
$sp2;a &lt;= (b & c) |<br>
$sp7;(d & e);
</_code>

<_pg>
If the expression <code> a &lt;= (b & c) | (d & e);<code> is not executed during simulation,
Covered will indicate that only one line was missed during execution (not two), and it will
display the missing line (if verbose reporting is specified with the '-d v' option) as the
following:
</_pg>

<_code>
$sp5;2:$sp6;assign a &lt;= (b & c) ...
</_code>

<_pg>
The "..." notation at the end of the Verilog output indicates that the expression was a
multiline expression in the source code but is only considered one line.
</_pg>

<_header2>
Toggle Coverage
</_header2>

<_header3>
Summary Information Description - Module-based
</_header3>

<_pg>
For module-based reports, the summary table for toggle metrics includes information for the
name of each module that was covered and the name of the file in which the module is
described in.  Lines <a href="test.rptM.html#19">19 through 25</a> of the module-based report
show what this information looks like in the report.  We have two modules that were scored
within our DUT:  main and foobar.  The table shows that both modules were described in the
file "test.v".
</_pg>

<_header3>
Summary Information Description - Instance-based
</_header3>

<_pg>
For instance-based reports, the summary table for toggle metrics includes information for
the Verilog hierarchy pertaining to each instance on the left-hand-side of each row.  Lines
<a href="test.rptI.html#25">25 through 31</a> of the instance-based report show what this
information looks like in the report.  In our DUT example, there are two instances within the
design with the Verilog hierarchies of "main" and "main.bar".
</_pg>

<_header3>
Summary Information Description - Both
</_header3>

<_pg>
On the right-hand side of each row in the table are the hit, miss and total numbers for the
toggle 0->1 coverage, followed by a calculated percent of the signal bits that toggled from
a value of 0 to a value of 1 (calculated by taking the number of bits that toggled from 0
to 1 during simulation divided by the total number of signal bits).  The hit value
indicates how many signal bits were toggle from a value of 0 to 1 during simulation; the
miss value indicates the number of signal bits that were not toggled from a value of 0 to
1 during simulation; and the total value indicates the total number of signal bits within
the specified module/instance that Covered was able to simulate.
</_pg>

<_pg>
To the right of this information is the hit, miss and total statistics for signal bits that
toggled from a value of 1 to a value of 0.
</_pg>

<_pg>
If the percentage values in the right of the summary table are 100%, this indicates that all
signal bits toggled from a value of 0 to 1 and back to 0 during simulating (for the
module/instance of this row).  If the values of the percentage are less than 100%, this
indicates that some signal bits did not fully toggle during simulation and full toggle
coverage was not achieved for that module/instance. Note that for a module/instance which
does not contain any signals in which Covered was able to simulate, the values of hit,
miss, and total will be 0 while the hit percentage value will indicate 100%.
</_pg>

<_header3>
Verbose Information Description - Both
</_header3>

<_pg>
If the miss value for a particular module/instance was not 0 (indicating that one or
more signal bits did not fully toggle during simulation) and the '-d v' option was
specified on the command-line (specifying to output verbose reporting information), the
signals that were missed during simulation will be output below the summary information
per module/instance that contained missed signal bit toggles.  In our sample module-based
report, there were seven signals in module "main" (a, b, c, d, e, f, and g) and two signals
in module "foobar" (a and c) that were not fully toggled (see lines
<a href="test.rptM.html#27>27 through 57</a>).  In our sample instance-based report, there
were also seven signals in instance "main" (a, b, c, d, e, f, and g) and two signals in
instance "main.bar" (a and c) that were not fully toggled (see lines
<a href="test.rptI.html#33">33 through 63</a>).
</_pg>

<_pg>
For each signal in the verbose toggle table, the format is the following:
</_pg>

<_margin>Signal toggle verbose output example</_margin>

<_code>
&lt;signal_name&gt;$sp10;0-&gt;1: &lt;binary_value&gt;<br>
.......................1-&gt;0: &lt;binary_value&gt;
</_code>

<_pg>
The name of the signal is specified in the upper left corner.  The bitwise toggle information
for the signal from a value of 0 to a value of 1 is specified in the upper right corner.  The
binary value represents bits in the signal, each bit corresponding to the matching bit of the
signal.  If a bit value is set to the value 1, this indicates that this bit in the signal
toggled from a value of 0 to a value of 1.  If a bit value is set to the value 0, this indicates
that this bit in the signal did NOT toggle from a value of 0 to a value of 1; therefore, full
toggle coverage was not achieved for this signal.  For example, for the signal called "g" in
the module/instance "main", the verbose toggle information looks like:
</_pg>

<_code>
g$sp10;0-&gt;1: 1'b1<br>
...........1-&gt;0: 1'b0
</_code>

<_pg>
This is indicating that bit 0 of the signal called "g" successfully toggled from a value
of 0 to 1 during simulation (because the bit value at bit location 0 is a value of 1).
However, the signal did not toggle from a value of 0 to a value of 1 during simulation,
thus the signal was not considered fully toggled.
</_pg>

<_pg>
It is important to note that the binary values are displayed with the least-significant bit
of the signal being output on the far right of the value while the most-significant bit of
the signal is output on the far left of the value.
</_pg>

<_header2>
Combinational Logic Coverage
</_header2>

<_header3>
Summary Information Description - Module-based
</_header3>

<_pg>
For module-based reports, the summary table for combinational logic metrics includes
information for the name of each module that was covered and the name of the file in which
the module is described in.  Lines <a href="test.rptM.html#60">60 through 66</a> of the
module-based report show what this information looks like in the report.  We have two
modules that were scored within our DUT:  main and foobar.  The table shows that both
modules were described in the file "test.v".
</_pg>

<_header3>
Summary Information Description - Instance-based
</_header3>

<_pg>
For instance-based reports, the summary table for combinational logic metrics includes
information for the Verilog hierarchy pertaining to each instance on the left-hand-side of
each row.  Lines <a href="test.rptI.html#66">66 through 72</a> of the instance-based report
show what this information looks like in the report.  In our DUT example, there are two
instances within the design with the Verilog hierarchies of "main" and "main.bar".
</_pg>

<_header3>
Summary Information Description - Both
</_header3>

<_pg>
On the right-hand side of each row in the table are the hit, miss and total numbers for the
combinational logic coverage, followed by a calculated percent of the combinational logic
expression values that were hit (calculated by taking the number of combinational logic
expression values hit during simulation divided by the total number of expression values
that Covered could have simulated).  The hit value indicates how many expression values
were achieved during the simulation; the miss value indicates the number of expression
values not achieved during simulation; and the total value indicates the total number of 
combinational logic expression values that could have been achieved in the specified
module/instance.
</_pg>

<_pg>
If the percentage value in the far left of the summary table is 100%, this indicates that
all combinational logic expression values that Covered was capable of achieving (for the
module/instance of this row) were hit.  If the value of the percentage is less than 100%,
this indicates that some number of expression values were not achieved and full coverage
was not achieved for that module/instance.  Note that for a module/instance which does not
contain any combinational logic expressions in which Covered was able to simulate, the
values of hit, miss, and total will be 0 while the hit percentage value will indicate 100%.
</_pg>

<_header3>
Verbose Information Description - Both
</_header3>

<_pg>
The verbose output for combinational coverage is a bit more sophisticated than the line or
toggle.  Basically, for each expression that was found to not be fully covered (either the
expression itself or some sub-expression in the tree was not fully covered), the expression
is output with various sub-expressions underlined and identified with a number.  Each
expression is also supplied with the line number that the expression started at in its module
file.  In our example, there is one expression in the module called "main" (see
lines <a href="test.rptM.html#74">74 through 77</a> and one expression in the module called
"foobar" (see lines <a href="test.rptM.html#112">112 through 113</a>.
</_pg>

<_pg>
Below each expression, there will be one or more tables which specify a particular
sub-expression that was not fully covered along with information describing what cases were
not covered for that sub-expression.
</_pg>

<_pg>
In the report output above, we see that there was one expression that did not have 100%
coverage on it and its subexpressions that starts on line 6 of the Verilog source.  The
expression is output to the report with certain sub-expressions underlined and labeled with
an integer value for reference.
</_pg>

<_pg>
For this one expression, there were found to be four subexpressions (labeled 1, 2, 6, 7) that
were found to not be 100% covered.  Taking a look at subexpression 1 report output, the
numbers to the right of the string "Expression 1" tell us the number of values of this
subexpression that were hit (in this case 1 value was hit) and the total number of values
that this subexpression can have (in this case 2 values were achievable).  The character
string below this information tells us the type of subexpression that we are examining.
For subexpression 1, the type is the unary NOT operator (~).
</_pg>

<_pg>
The table below this information for subexpression 1, lists the potential values that this
subexpression could have reached with a '*' character placed underneath the value(s) that was
missed.  In the case of subexpression 1, the value of 0 was not hit (meaning that the value
of the register b was never assigned the value of 1).  The letter 'E' above each possible
value indicates that this subexpression is a unary expression (its value comes from one
variable) and 'E' represents this subexpression's value (not the value of its subexpressions).
</_pg>

<_header2>
Finite State Machine Coverage
</_header2>

<_header3>
Summary Information Description - Module-based
</_header3>

<_pg>
For module-based reports, the summary table for FSM metrics includes information for the
name of each module that was covered and the name of the file in which the module is
described in.  Lines <a href="test.rptM.html#125">125 through 131</a> of the module-based
report show what this information looks like in the report.  We have two modules that were
scored within our DUT:  main and foobar.  The table shows that both modules were described
in the file "test.v".
</_pg>

<_header3>
Summary Information Description - Instance-based
</_header3>

<_pg>
For instance-based reports, the summary table for FSM metrics includes information for
the Verilog hierarchy pertaining to each instance on the left-hand-side of each row.  Lines
<a href="test.rptI.html#131">131 through 137</a> of the instance-based report show what this
information looks like in the report.  In our DUT example, there are two instances within the
design with the Verilog hierarchies of "main" and "main.bar".
</_pg>

<_header3>
Summary Information Description - Both
</_header3>

<_pg>
On the right-hand side of each row in the table are the hit, miss and total numbers for the
FSM state coverage, followed by a calculated percent of the FSM states that were hit
(calculated by taking the number of FSM states hit during simulation divided by the total
number of FSM states that Covered could have simulated).  The hit value indicates how many
FSM states were executed during the simulation; the miss value indicates the number of FSM
states not executed during simulation; and the total value indicates the total number of FSM
states within the specified module/instance that Covered can simulate.
</_pg>

<_pg>
To the right of the FSM state summary information is the FSM state-transition hit, miss,
total and percentage hit summary information for each module/instance.
</_pg>

<_pg>
If the percentage value in the far left of the summary table is 100%, this indicates that all
FSM states and state-transitions that Covered was capable of simulating (for the
module/instance of this row) were executed.  If the value of the percentage is less than
100%, this indicates that some number of FSM states and/or FSM state-transitions were not
executed and full coverage was not achieved for that module/instance.  Note that for a
module/instance which does not contain any FSMs in which Covered was able to
simulate, the values of hit, miss, and total will be 0 while the hit percentage value will
indicate 100%.
</_pg>

<_header3>
Verbose Information Description - Both
</_header3>

<_pg>
The verbose output for FSM coverage is split into the state coverage information
and the state transition coverage information.  When an FSM is found to be not
fully covered (i.e., the number of hit states/state transitions is not equal to
the number of attainable states/state transitions), the missed states are output
to the report as a list of state values in hexidecimal format as follows:
</_pg>

<_pg>
&lt;<i>hexidecimal value</i>&gt;
</_pg>

<_pg>
When an FSM is found to be not fully covered, the missed state transitions are
output to the report as a list of state transitions in the format below:
</_pg>

<_pg>
&lt;<i>hexidecimal input state value</i>&gt; -&gt; &lt;<i>hexidecimal output state value</i>&gt;
</_pg>

<_pg>
If the -c option is used or the number of attainable state/state transitions are
unknown for the specified FSM, Covered outputs this information in the same way
as the missed cases except that the title of the output is "Hit cases".  If the
number of attainable states/state transitions is unknown, providing the cases that
were hit during simulation is useful in aiding the user in determining coverage.
In this case, the summary report will output question marks in the missed and total
categories, showing the user that this information was not known by Covered.
</_pg>
