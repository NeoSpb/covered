<!--
[variables]
{
  $page_title = "Inline Attributes"
  $page_title_english = "Inline Attributes"
  $file_prev = "011.html"
  $file_next = "013.html"
  $real_page_number = "12"
  $page_number = "12"
}
-->

<_header1>
$page_title
</_header1>

<_header2>
What are inline attributes?
</_header2>

<_pg>
In the IEEE Verilog 1364-2001 standard, an attribute is a way to add information to a
Verilog object, statement or groups of statements that is tool-specific and does not affect
simulation of that design.  All Verilog-2001 attributes begin with the token
<strong>(*</strong> and end with the token <strong>*)</strong>.  An attribute can be
multi-line and is "attached" to the Verilog object, statement, or group of statements that
is specified immediately beneath the attribute.
</_pg>

<_pg>
Covered uses the Verilog-2001 attribute for allowing users to specify coverage-specific
information about embedded objects within a particular design.  When an attribute is found,
it is interrogated to see if it is a Covered attribute.  If the attribute is a Covered
attribute, its contents are parsed.  If the attribute is not found to be a Covered attribute,
it is ignored and parsing continues normally.
</_pg>

<_pg>
The rest of this page specifies the attributes that Covered is capable of handling, along
with their use and syntax.
</_pg>

<_header2>
Adding FSM attributes
</_header2>

<_pg>
There are two ways that Covered currently allows the user to specify the location of and
information about FSMs embedded in a particular design.  The first way to specify an FSM is
on the score command-line.  The benefit to specifying the location of a state machine this way
is that the source code does not need to be modified.  The potential disadvantage to this
method is that the FSM location and coverage information can get lost if the FSM is used in
a different testbench (or even a different project if the FSM code is reused in a later
project).  For more information on specifying an FSM on the score command-line, please
refer to "Section 8.5  Scoring FSMs".
</_pg>

<_pg>
The second way that an FSM can be specified to Covered is through the use of the Verilog-2001
attribute.  The advantages to using this method are that the FSM information specified in
an attribute stays embedded in the design (for ease of reusing the FSM and still retaining
information relevent to coverage).  Additionally, at the current release of Covered, using attributes to specify an FSM is the only
way to tell Covered what all of the valid states and state-transitions are for a specific
FSM (the command-line specification does not allow for this).  This provides a unique
advantage of this method over the command-line method.  The potential disadvantage of this
method for specifying FSM information is that source code needs to be modified.
</_pg>

<_pg>
To learn how to specify an FSM attribute within a design, let's use an example of an FSM that
is embedded in a design.
</_pg>

<_margin>Example FSM</_margin>

<_code>
module foo (<br>
$sp$sp clk,<br>
$sp$sp reset,<br>
$sp$sp head,<br>
$sp$sp tail,<br>
$sp$sp valid<br>
);<br>
<br>
input$sp$sp clk;<br>
input$sp$sp reset;<br>
input$sp$sp head;<br>
input$sp$sp tail;<br>
input$sp$sp valid;<br>
<br>
parameter STATE_IDLE = 2'b00,<br>
$sp$sp$sp$sp$sp$sp$sp$sp$sp STATE_HEAD = 2'b01,<br>
$sp$sp$sp$sp$sp$sp$sp$sp$sp STATE_DATA = 2'b10,<br>
$sp$sp$sp$sp$sp$sp$sp$sp$sp STATE_TAIL = 2'b11;<br>
<br>
reg [1:0] state;<br>
reg [1:0] next_state;<br>
<br>
always @(posedge clock)<br>
$sp state <= reset ? STATE_IDLE : next_state;<br>
<br>
always @(reset or state or head or valid or tail)<br>
$sp begin<br>
$sp$sp$ case( state )<br>
$sp$sp$sp$sp STATE_IDLE: next_state = (valid & head) ? STATE_HEAD :<br>
$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp
$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp STATE_IDLE;<br>
$sp$sp$sp$sp STATE_HEAD: next_state = (valid & tail) ? STATE_TAIL :<br>
$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp
$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp STATE_DATA;<br>
$sp$sp$sp$sp STATE_DATA: next_state = (valid & tail) ? STATE_TAIL :<br>
$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp
$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp STATE_DATA;<br>
$sp$sp$sp$sp STATE_TAIL: next_state = (valid & head) ? STATE_HEAD :<br>
$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp
$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp$sp STATE_IDLE;<br>
$sp$sp endcase<br>
$sp end<br>
<br>
endmodule
</_code>

<_pg>
This example shows an FSM that has an input FSM variable called "state" and an output FSM
variable called "next_state".  There are four states in the state machine that are
represented with the parameters located in this module (STATE_IDLE, STATE_HEAD, STATE_DATA,
STATE_TAIL).  There are a total of eight (8) state transitions that this FSM can take.  They
are the following:
</_pg>

<_margin>FSM state transitions</_margin>

<_pg>
<ol>
  <li> STATE_IDLE -> STATE_IDLE (loopback) </li>
  <li> STATE_IDLE -> STATE_HEAD </li>
  <li> STATE_HEAD -> STATE_DATA </li>
  <li> STATE_HEAD -> STATE_TAIL </li>
  <li> STATE_DATA -> STATE_DATA (loopback) </li>
  <li> STATE_DATA -> STATE_TAIL </li>
  <li> STATE_TAIL -> STATE_HEAD </li>
  <li> STATE_TAIL -> STATE_IDLE </li>
</ol>
</_pg>

<_pg>
All attributes that specify information for an FSM are a comma-separated list of values
that contain the following information:
</_pg>

<_pg>
<ol>
  <li> "covered_fsm" attribute keyword
    <ul>
       <li> MUST be first value in the attribute list </li>
       <li> Specifies to Covered that this attribute contains information for an FSM that
            Covered needs to handle. </li>
    </ul></li>
  <li> FSM identifier
    <ul>
       <li> MUST be second value in the attribute list </li>
       <li> Specifies a alphanumeric name for this FSM. </li>
       <li> The name will eventually be used to tie individual attributes that specify
            information for the same FSM. </li>
    </ul></li>
  <li> Input state expression (optional)
    <ul>
      <li> Syntax:  <code>is="</code><i>expression</i><code>"</code> </li>
      <li> If this is specified, MUST be specified third in the list. </li>
      <li> Specifies the input state expression. </li>
      <li> Can be a combination of signal names, signal bit selects, and concatenation
           operators. </li>
      <li> See "Section 8.5. Specifying an FSM" for more information on the specification
           of an input state expression. </li>
    </ul></li>
  <li> Output state expression
    <ul>
      <li> Syntax:  <code>os="</code><i>expression</i><code>"</code> </li>
      <li> If the input state expression is specified, MUST be fourth value in list;
           otherwise, MUST be third value in list. </li>
      <li> Specifies the output state expression of the FSM. </li>
      <li> Can be a combination of signal names, signal bit selects, and concatenation
           operators. </li>
      <li> See "Section 8.5. Specifying an FSM" for more information on the specification
           of an output state expression. </li>
    </ul></li>
  <li> State-transition specifiers (optional)
    <ul>
      <li> Syntax:  <code>trans="</code><i>from_state</i><code>-&gt;</code><i>to_state</i><code>"</code> </li>
      <li> MUST be specified after the above has been specified in the list. </li>
      <li> Arguments MUST be constant values (parameters; numerical values --
           binary, octal, decimal, hexidecimal; and defines that equate to one of these
           two types of values).</li>
      <li> Each transition that is specified is a unique value in the attribute list. </li>
    </ul></li>
</ol>
  
</_pg>

<_pg>
To specify the FSM attribute in the above example, including input state, output state and
all state transitions, the code would be modified to look like:
</_pg>

<_margin>Modified Example</_margin>

<_code>
...<br>
<br>
(* covered_fsm, channel, is="state", os="next_state",<br>
$sp$sp trans="STATE_IDLE-&gt;STATE_IDLE",<br>
$sp$sp trans="STATE_IDLE-&gt;STATE_HEAD",<br>
$sp$sp trans="STATE_HEAD-&gt;STATE_DATA",<br>
$sp$sp trans="STATE_HEAD-&gt;STATE_TAIL",<br>
$sp$sp trans="STATE_DATA-&gt;STATE_DATA",<br>
$sp$sp trans="STATE_DATA-&gt;STATE_TAIL",<br>
$sp$sp trans="STATE_TAIL-&gt;STATE_HEAD",<br>
$sp$sp trans="STATE_TAIL-&gt;STATE_IDLE" *)<br>
always @(reset or state or head or tail or valid)<br>
...
</_code>
