\section{statement.c File Reference}
\label{statement_8c}\index{statement.c@{statement.c}}
{\tt \#include $<$stdio.h$>$}\par
{\tt \#include $<$assert.h$>$}\par
{\tt \#include $<$string.h$>$}\par
{\tt \#include \char`\"{}defines.h\char`\"{}}\par
{\tt \#include \char`\"{}statement.h\char`\"{}}\par
{\tt \#include \char`\"{}expr.h\char`\"{}}\par
{\tt \#include \char`\"{}util.h\char`\"{}}\par
{\tt \#include \char`\"{}link.h\char`\"{}}\par
{\tt \#include \char`\"{}sim.h\char`\"{}}\par
\subsection*{Functions}
\begin{CompactItemize}
\item 
{\bf statement} $\ast$ {\bf statement\_\-create} ({\bf expression} $\ast$exp)
\begin{CompactList}\small\item\em Creates new statement structure.\item\end{CompactList}\item 
void {\bf statement\_\-stack\_\-push} ({\bf statement} $\ast$stmt, int id)
\item 
void {\bf statement\_\-stack\_\-compare} ({\bf statement} $\ast$stmt)
\item 
void {\bf statement\_\-db\_\-write} ({\bf statement} $\ast$stmt, FILE $\ast$ofile, char $\ast$scope)
\begin{CompactList}\small\item\em Writes specified statement to the specified output file.\item\end{CompactList}\item 
{\bf bool} {\bf statement\_\-db\_\-read} (char $\ast$$\ast$line, {\bf module} $\ast$curr\_\-mod, int read\_\-mode)
\begin{CompactList}\small\item\em Reads in statement line from specified string and stores statement in specified module.\item\end{CompactList}\item 
void {\bf statement\_\-connect} ({\bf statement} $\ast$curr\_\-stmt, {\bf statement} $\ast$next\_\-stmt)
\begin{CompactList}\small\item\em Connects statement sequence to next statement.\item\end{CompactList}\item 
void {\bf statement\_\-set\_\-stop} ({\bf statement} $\ast$stmt, {\bf statement} $\ast$post, {\bf bool} true\_\-path, {\bf bool} both)
\begin{CompactList}\small\item\em Sets stop bits in specified statement tree.\item\end{CompactList}\item 
void {\bf statement\_\-dealloc} ({\bf statement} $\ast$stmt)
\begin{CompactList}\small\item\em Deallocates statement memory and associated expression tree from the heap.\item\end{CompactList}\end{CompactItemize}
\subsection*{Variables}
\begin{CompactItemize}
\item 
{\bf stmt\_\-loop\_\-link} $\ast$ {\bf stmt\_\-loop\_\-stack} = NULL
\item 
char {\bf user\_\-msg} [USER\_\-MSG\_\-LENGTH]
\end{CompactItemize}


\subsection{Detailed Description}


\begin{Desc}
\item[Author: ]\par
Trevor Williams ({\tt trevorw@charter.net}) \end{Desc}
\begin{Desc}
\item[Date: ]\par
5/1/2002

 Statements are used to indicate flow of execution for a given always or initial block. Each statement is assigned to exactly one expression tree and it contains a pointer to the next statement if its expression tree evaluates to TRUE (non-zero value) or FALSE (zero value). To minimize memory use, a statement  uses some of the unused bits in its root expression supplemental field instead of having its own supplemental field. There are two bits in the expression supplemental value that are only used by expressions: {\bf SUPPL\_\-LSB\_\-STMT\_\-HEAD} {\rm (p.\,\pageref{group__expr__suppl_a4})} and {\bf SUPPL\_\-LSB\_\-STMT\_\-STOP} {\rm (p.\,\pageref{group__expr__suppl_a5})}.

 The STMT\_\-HEAD bit indicates that this statement should be loaded into the pre-simulation statement queue if any of its expressions change value in the current timestep. To begin with, the first statement in the always/initial block has this bit set, all other statements have this bit cleared.

 The STMT\_\-STOP bit is used for CDD output. If a statement has this bit set, it will not traverse its next\_\-true or next\_\-false paths when outputting. This is necessary when statement paths merge back to the same path. If this bit was not used, the statements output after the merge would be output twice. Consider the following Verilog code snippet:\end{Desc}


\footnotesize\begin{verbatim} intial begin
        a = 0;
        if( a )
          b = 1;
        else
          b = 0;
        c = a | b;
 end
\end{verbatim}\normalsize 


 In this example there are five statements. They are the following:

\begin{enumerate}
\item 


\footnotesize\begin{verbatim}a = 0; 
\end{verbatim}\normalsize 
\item 


\footnotesize\begin{verbatim}if( a ) 
\end{verbatim}\normalsize 
\item 


\footnotesize\begin{verbatim}b = 1; 
\end{verbatim}\normalsize 
\item 


\footnotesize\begin{verbatim}b = 0; 
\end{verbatim}\normalsize 
\item 


\footnotesize\begin{verbatim}c = a | b; 
\end{verbatim}\normalsize 
\end{enumerate}


 Notice that the if statement has two paths. If a is TRUE, statement 3 is executed; otherwise, statement 4 is executed. Both statements 3 and 4 then merge to execute statement 5. If the entire statement tree were printed without a STOP bit, you can see that statement 5 would be output twice; once for the TRUE branch and once for the FALSE branch.

 To eliminate this redundancy, the STMT\_\-STOP bit is set on statement 4. The last statement of a TRUE path before merging always gets its STMT\_\-STOP bit set. The FALSE path should never get the STMT\_\-STOP bit set. Additionally, once a statement gets its STMT\_\-STOP bit set by the parser, this value must be maintained (never cleared).\begin{Desc}
\item[Cyclic Statement Trees]\par
 Many times a statement tree will \char`\"{}loopback\char`\"{} on itself. These statement trees are considered to be cyclic in nature and, as such, must have leaf statements of the statement tree tied to the first statement of the tree. The following Verilog constructs have cyclic behavior: {\tt always}, {\tt forever}, {\tt for}, {\tt repeat}, and {\tt while}.\end{Desc}
\begin{Desc}
\item[Traversing Statement Tree]\par
 Starting at the head statement, the value of the head statement is determined to be TRUE or FALSE. If the value is TRUE (non-zero), the next\_\-true path is taken. If the value is FALSE (zero), the next\_\-false path is taken. For statements that express an assignment (or other statements that do not branch), both the next\_\-true and next\_\-false paths point to the same statement. For statements that express a wait-for-event (ex. {\tt wait}, {\tt @}, etc.), the next\_\-true pointer will point to the next statement in the tree; however, the next\_\-false pointer will point to NULL. This NULL assignment indicates to the statement simulation engine that this statement will receive the STMT\_\-HEAD bit and the current statement tree is finished for this timestep.\end{Desc}


\subsection{Function Documentation}
\index{statement.c@{statement.c}!statement_connect@{statement\_\-connect}}
\index{statement_connect@{statement\_\-connect}!statement.c@{statement.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void statement\_\-connect ({\bf statement} $\ast$ {\em curr\_\-stmt}, {\bf statement} $\ast$ {\em next\_\-stmt})}\label{statement_8c_a7}


Connects statement sequence to next statement.

\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
curr\_\-stmt}]Pointer to statement sequence to traverse. \item[{\em 
next\_\-stmt}]Pointer to statement to connect ends to.\end{description}
\end{Desc}
Recursively traverses the specified stmt sequence. When it reaches a statement  that has either next\_\-true or next\_\-false set to NULL, sets next\_\-true and/or  next\_\-false of that statement to point to the next\_\-stmt statement. \index{statement.c@{statement.c}!statement_create@{statement\_\-create}}
\index{statement_create@{statement\_\-create}!statement.c@{statement.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf statement}$\ast$ statement\_\-create ({\bf expression} $\ast$ {\em exp})}\label{statement_8c_a2}


Creates new statement structure.

\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
exp}]Pointer to root expression of expression tree for this statement.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns: ]\par
Returns pointer to the newly created statement.\end{Desc}
Creates a new statement structure from heap memory and initializes it with the specified parameter information. \index{statement.c@{statement.c}!statement_db_read@{statement\_\-db\_\-read}}
\index{statement_db_read@{statement\_\-db\_\-read}!statement.c@{statement.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf bool} statement\_\-db\_\-read (char $\ast$$\ast$ {\em line}, {\bf module} $\ast$ {\em curr\_\-mod}, int {\em read\_\-mode})}\label{statement_8c_a6}


Reads in statement line from specified string and stores statement in specified module.

\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
line}]Pointer to current line of file being read. \item[{\em 
curr\_\-mod}]Pointer to current module. \item[{\em 
read\_\-mode}]If set to REPORT, adds statement to head of list; otherwise, adds statement to tail.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns: ]\par
Returns TRUE if the line is read without error; otherwise, returns FALSE.\end{Desc}
Reads in the contents of the statement from the specified line, creates a statement structure to hold the contents. \index{statement.c@{statement.c}!statement_db_write@{statement\_\-db\_\-write}}
\index{statement_db_write@{statement\_\-db\_\-write}!statement.c@{statement.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void statement\_\-db\_\-write ({\bf statement} $\ast$ {\em stmt}, FILE $\ast$ {\em ofile}, char $\ast$ {\em scope})}\label{statement_8c_a5}


Writes specified statement to the specified output file.

\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
stmt}]Pointer to statement to write out value. \item[{\em 
ofile}]Pointer to output file to write statement line to. \item[{\em 
scope}]Scope of parent module which contains the specified statement.\end{description}
\end{Desc}
Recursively writes the contents of the specified statement tree (and its associated expression trees to the specified output stream. \index{statement.c@{statement.c}!statement_dealloc@{statement\_\-dealloc}}
\index{statement_dealloc@{statement\_\-dealloc}!statement.c@{statement.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void statement\_\-dealloc ({\bf statement} $\ast$ {\em stmt})}\label{statement_8c_a9}


Deallocates statement memory and associated expression tree from the heap.

\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
stmt}]Pointer to statement to deallocate.\end{description}
\end{Desc}
Deallocates specified statement from heap memory. First remove expression tree of this statement. Second, remove all statements following this statement. Finally, remove the specified statement itself. Since statements can be circular in nature, we will not remove a statement that has its expression tree already deallocated. This will prevent this function from getting into an infinite loop (or stack overflow since this function is recursive). \index{statement.c@{statement.c}!statement_set_stop@{statement\_\-set\_\-stop}}
\index{statement_set_stop@{statement\_\-set\_\-stop}!statement.c@{statement.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void statement\_\-set\_\-stop ({\bf statement} $\ast$ {\em stmt}, {\bf statement} $\ast$ {\em post}, {\bf bool} {\em true\_\-path}, {\bf bool} {\em both})}\label{statement_8c_a8}


Sets stop bits in specified statement tree.

\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
stmt}]Pointer to top of statement tree to set stop bits for. \item[{\em 
post}]Pointer to statement that comes just after the stopped statement. \item[{\em 
true\_\-path}]Set to TRUE if the current statement exists on the right of its parent. \item[{\em 
both}]If TRUE, causes both false and true paths to set stop bits when next statement is the post statement.\end{description}
\end{Desc}
Recursively traverses specified statement tree, setting the statement's stop bits that have either their next\_\-true or next\_\-false pointers pointing to the statement called post. \index{statement.c@{statement.c}!statement_stack_compare@{statement\_\-stack\_\-compare}}
\index{statement_stack_compare@{statement\_\-stack\_\-compare}!statement.c@{statement.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void statement\_\-stack\_\-compare ({\bf statement} $\ast$ {\em stmt})}\label{statement_8c_a4}


\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
stmt}]Pointer to statement being read out of the CDD.\end{description}
\end{Desc}
Compares the specified statement against the top of the statement loop stack. If the ID at the top of the stack matches this statement's ID, the top of the stack is popped and the next\_\-true and next\_\-false pointers of the stored statement are pointed to the specified statement. The next head is also compared against this statement and the process is repeated until a match is not found. Once an ID at the top of the stack does not match, no further action is taken. \index{statement.c@{statement.c}!statement_stack_push@{statement\_\-stack\_\-push}}
\index{statement_stack_push@{statement\_\-stack\_\-push}!statement.c@{statement.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void statement\_\-stack\_\-push ({\bf statement} $\ast$ {\em stmt}, int {\em id})}\label{statement_8c_a3}


\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
stmt}]Pointer of statement waiting to be linked. \item[{\em 
id}]ID of statement to be read out later.\end{description}
\end{Desc}
Creates a new statement loop link for the specified parameters and adds this element to the top of the statement loop stack. 

\subsection{Variable Documentation}
\index{statement.c@{statement.c}!stmt_loop_stack@{stmt\_\-loop\_\-stack}}
\index{stmt_loop_stack@{stmt\_\-loop\_\-stack}!statement.c@{statement.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf stmt\_\-loop\_\-link}$\ast$ stmt\_\-loop\_\-stack = NULL}\label{statement_8c_a0}


\index{statement.c@{statement.c}!user_msg@{user\_\-msg}}
\index{user_msg@{user\_\-msg}!statement.c@{statement.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}char user\_\-msg[USER\_\-MSG\_\-LENGTH]}\label{statement_8c_a1}


