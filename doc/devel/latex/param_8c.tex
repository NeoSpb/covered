\section{param.c File Reference}
\label{param_8c}\index{param.c@{param.c}}
{\tt \#include $<$stdio.h$>$}\par
{\tt \#include $<$stdlib.h$>$}\par
{\tt \#include $<$string.h$>$}\par
{\tt \#include $<$assert.h$>$}\par
{\tt \#include \char`\"{}defines.h\char`\"{}}\par
{\tt \#include \char`\"{}param.h\char`\"{}}\par
{\tt \#include \char`\"{}util.h\char`\"{}}\par
{\tt \#include \char`\"{}link.h\char`\"{}}\par
{\tt \#include \char`\"{}signal.h\char`\"{}}\par
{\tt \#include \char`\"{}expr.h\char`\"{}}\par
\subsection*{Functions}
\begin{CompactItemize}
\item 
{\bf parameter} $\ast$ {\bf param\_\-find} (char $\ast$name, {\bf parameter} $\ast$parm)
\begin{CompactList}\small\item\em Searches specified parameter list for the specified parameter name.\item\end{CompactList}\item 
{\bf parameter} $\ast$ {\bf param\_\-find\_\-and\_\-remove} (char $\ast$name, {\bf parameter} $\ast$$\ast$head, {\bf parameter} $\ast$$\ast$tail)
\item 
void {\bf param\_\-add\_\-to\_\-list} ({\bf parameter} $\ast$parm, {\bf parameter} $\ast$$\ast$head, {\bf parameter} $\ast$$\ast$tail)
\item 
void {\bf param\_\-add} (char $\ast$name, {\bf expression} $\ast$expr, {\bf module} $\ast$mod)
\begin{CompactList}\small\item\em Adds parameter to specified module's parameter list.\item\end{CompactList}\item 
void {\bf param\_\-add\_\-defparam} (char $\ast$scope, {\bf vector} $\ast$value)
\begin{CompactList}\small\item\em Adds parameter override to defparam list.\item\end{CompactList}\end{CompactItemize}
\subsection*{Variables}
\begin{CompactItemize}
\item 
{\bf parameter} $\ast$ {\bf defparam\_\-head} = NULL
\item 
{\bf parameter} $\ast$ {\bf defparam\_\-tail} = NULL
\end{CompactItemize}


\subsection{Detailed Description}


\begin{Desc}
\item[Author: ]\par
Trevor Williams ({\tt trevorw@charter.net}) \end{Desc}
\begin{Desc}
\item[Date: ]\par
8/22/2002\end{Desc}
The following is a list of the goals that I would ideally like for parameters:

\begin{enumerate}
\item 
All parameter information is encapsulated in a module structure (nothing in the instance structures).\end{enumerate}
\begin{enumerate}
\item 
Parameter support should have a minimal impact on parsing performance.\end{enumerate}
\begin{enumerate}
\item 
All parameter information should be handled by the time that the parsed information is initially output to the CDD file.\end{enumerate}
\begin{enumerate}
\item 
The defparam statement will be ignored for all found statements and a warning generated to standard error for all found defparams.\end{enumerate}
\begin{enumerate}
\item 
Parameter overloading will be allowed at the instance declaration for instances that are deemed to be parsed.\end{enumerate}
\begin{enumerate}
\item 
A Verilog module need only be parsed once.\end{enumerate}
\begin{enumerate}
\item 
No module copying is to occur.\end{enumerate}
\begin{enumerate}
\item 
Parameter structure is to be as condensed as possible. A parameter structure should contain at least the following information:\begin{CompactItemize}
\item 
Name of parameter in module OR relative hierarchical name of parameter in submodule.\item 
Pointer to vector containing value of parameter or parameter override (might require expression tree instead of vector -- root of expression tree eventually contains vector value of parameter).\end{CompactItemize}
\end{enumerate}
\begin{enumerate}
\item 
Any code allowed for assigning parameters is allowed (with the noted exception of the defparam statement).\end{enumerate}
So how do all of these goals get met?

\begin{enumerate}
\item 
All parameter information can be stored in the module structure by storing parameter assignments and parameter overloads (for submodules) in current module.\end{enumerate}
\begin{enumerate}
\item 
Both signals and expressions will need to change the way that they write themselves to the CDD file. If a signal's width/lsb is determined with parameters, the signal and associated expressions will need to have width's and/or lsb's reset to new values. If an expression's value is determined with parameters, the expression will need to have width's reset to new values.\end{enumerate}
\begin{enumerate}
\item 
If all Verilog information can be contained in the module structure only, it will not be necessary to reparse a module or to copy an existing module.\end{enumerate}
\begin{enumerate}
\item 
It is important to note that parameters can have chain reactions in submodule evaluations due to instance parameter overriding of parameters that are used to override other submodule instance parameters. Therefore, all parameters will need to be evaluated in a top-down manner (root module will need to be evaluated first followed by its children, etc.)\end{enumerate}
\begin{enumerate}
\item 
All defparam values supplied by the user must be static values (no expressions allowed).\end{enumerate}
\begin{enumerate}
\item 
Defparam overrides should be applied before default values to eliminate unnecessary default parameter expression evaluation.\end{enumerate}
\begin{enumerate}
\item 
Expression trees need to be stored in module parameter lists for parameter expressions.\end{enumerate}


\subsection{Function Documentation}
\index{param.c@{param.c}!param_add@{param\_\-add}}
\index{param_add@{param\_\-add}!param.c@{param.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void param\_\-add (char $\ast$ {\em name}, {\bf expression} $\ast$ {\em expr}, {\bf module} $\ast$ {\em mod})}\label{param_8c_a5}


Adds parameter to specified module's parameter list.

\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
name}]Full hierarchical name of parameter value. \item[{\em 
expr}]Expression to calculate parameter value. \item[{\em 
mod}]Pointer to module to store default parameter value.\end{description}
\end{Desc}
Creates a new parameter with the specified information and adds it to the  instance parameter list. This function is only called when a parameter is found in a particular module.

Note: Necessary \index{param.c@{param.c}!param_add_defparam@{param\_\-add\_\-defparam}}
\index{param_add_defparam@{param\_\-add\_\-defparam}!param.c@{param.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void param\_\-add\_\-defparam (char $\ast$ {\em scope}, {\bf vector} $\ast$ {\em value})}\label{param_8c_a6}


Adds parameter override to defparam list.

\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
scope}]Full hierarchical reference to specified scope to change value to. \item[{\em 
value}]User-specified parameter override value.\end{description}
\end{Desc}
Scans list of all parameters to make sure that specified parameter isn't already being set to a new value. If no match occurs, creates a new parameter link and places at the tail of the parameter list. If match is found, display error message to user and exit covered immediately. This function is called for each -P option to the score command.

Note: Necessary -- used by {\bf score.c} \index{param.c@{param.c}!param_add_to_list@{param\_\-add\_\-to\_\-list}}
\index{param_add_to_list@{param\_\-add\_\-to\_\-list}!param.c@{param.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void param\_\-add\_\-to\_\-list ({\bf parameter} $\ast$ {\em parm}, {\bf parameter} $\ast$$\ast$ {\em head}, {\bf parameter} $\ast$$\ast$ {\em tail})}\label{param_8c_a4}


\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
parm}]Pointer to parameter to add to specified list. \item[{\em 
head}]Pointer to head parameter in list. \item[{\em 
tail}]Pointer to tail parameter in list.\end{description}
\end{Desc}
Adds specified parameter to the tail of the specified parameter list.

Note: Necessary \index{param.c@{param.c}!param_find@{param\_\-find}}
\index{param_find@{param\_\-find}!param.c@{param.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf parameter}$\ast$ param\_\-find (char $\ast$ {\em name}, {\bf parameter} $\ast$ {\em parm})}\label{param_8c_a2}


Searches specified parameter list for the specified parameter name.

\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
name}]Name of parameter value to find. \item[{\em 
parm}]Pointer to head of parameter list to search.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns: ]\par
Returns pointer to found parameter or NULL if parameter is not found.\end{Desc}
Searches specified parameter list for a parameter that matches the name of the specified parameter. If a match is found, a pointer to the found parameter is returned to the calling function; otherwise, a value of NULL is returned if no match was found.

Note: Necessary \index{param.c@{param.c}!param_find_and_remove@{param\_\-find\_\-and\_\-remove}}
\index{param_find_and_remove@{param\_\-find\_\-and\_\-remove}!param.c@{param.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf parameter}$\ast$ param\_\-find\_\-and\_\-remove (char $\ast$ {\em name}, {\bf parameter} $\ast$$\ast$ {\em head}, {\bf parameter} $\ast$$\ast$ {\em tail})}\label{param_8c_a3}


\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
name}]Name of parameter to search for in current list. \item[{\em 
head}]Pointer to head of parameter list to search. \item[{\em 
tail}]Pointer to tail of parameter list to search.\end{description}
\end{Desc}
\begin{Desc}
\item[Returns: ]\par
Returns pointer to found parameter or NULL if parameter was not found.\end{Desc}
Iterates through specified parameter list searching for parameter whose name matches the specified string. If a match is found, it is removed from the specified list and returned to the calling function. If no match is found, nothing is removed from the  list and we return NULL to the calling function. 

\subsection{Variable Documentation}
\index{param.c@{param.c}!defparam_head@{defparam\_\-head}}
\index{defparam_head@{defparam\_\-head}!param.c@{param.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf parameter}$\ast$ defparam\_\-head = NULL}\label{param_8c_a0}


Pointer to head of parameter list for global defparams \index{param.c@{param.c}!defparam_tail@{defparam\_\-tail}}
\index{defparam_tail@{defparam\_\-tail}!param.c@{param.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf parameter}$\ast$ defparam\_\-tail = NULL}\label{param_8c_a1}


Pointer to tail of parameter list for global defparams 