\section{Introduction}\label{page_intro}
 \begin{Desc}
\item[What is a code coverage tool used for?]\par
 Covered is a Verilog code coverage analysis tool that can be useful for determining how well a diagnostic test suite is covering the design under test. Typically in the design verification work flow, a design verification engineer will develop a self-checking test suite to verify design elements/functions specified by a design's specification document. When the test suite contains all of the tests required by the design specification, the test writer may be asking him/herself, \char`\"{}How much logic in the design is actually being exercised?\char`\"{}, \char`\"{}Does my test suite cover all of the logic under test?\char`\"{}, and \char`\"{}Am I done writing tests for the logic?\char`\"{}. When the design verification gets to this point, it is often useful to get some metrics for determining logic coverage. This is where a code coverage utility, such as Covered, is very useful.

 The metrics obtained by using a code coverage analysis tool can be very useful for determining the following about a design and the test suite testing that design:\begin{enumerate}
\item 
Completeness of the test suite in terms of logic coverage.\item 
Unexercised logic in the design (useful in helping to determine what types of tests need to be added to the test suite).\item 
Corner cases in design that are untestable.\end{enumerate}
\end{Desc}


 It is very important to note that any code coverage tool is only useful in indicating how much logic is being covered by a test suite. It does not indicate that the covered logic works appropriately. This, of course, can only be verified by the diagnostics themselves. Additionally, it is possible that two or more diagnostics can achieve the same coverage and yet be functionally testing different features in the design. Since the coverage metrics are not improved in this case, one may conclude that the second test is unneccessary. This may or may not be true depending on what is being tested, it is always up to the test writer to determine the necessity of the diagnostic. Using the code coverage tool results as the sole means of making this determination is not recommended. Use common sense in these areas.\begin{Desc}
\item[What does Covered do?]\par
 Covered is a tool that uses your design files along with specialized VCD dump files to analyze the code coverage of the design. The code coverage information is stored in a special database file that can be retrieved and \char`\"{}merged\char`\"{} with new coverage information to create a summed coverage total for several tests. After a database file has been create, the user may generate reports that summarize the coverage information.\end{Desc}
\begin{Desc}
\item[Covered Metrics]\par
 Covered currently generates four types of code coverage metrics. Each of these metrics is described in detail in the following subsections:\end{Desc}
\begin{Desc}
\item[Line Coverage Description]\par
 Line coverage simply answers the question, \char`\"{}Was this line of code executed during simulation?\char`\"{} Covered will display the number of logical lines of code that exist in a particular file with the number of logical lines that were executed during the simulation along with a percentage indicating the percentage of lines executed. If verbose mode is selected for a report, Covered will display the lines of logic that were not executed during the simulation run.

 For a design to pass full coverage, it is recommended that the line coverage for all modules in a design receive 100\% coverage. If a line of logic is not executed during simulation, the design has not been fully exercised. Line coverage is useful for determining holes in the test suite.\end{Desc}
\begin{Desc}
\item[Toggle Coverage Description]\par
 Toggle coverage answers the question, \char`\"{}Did this bit of this wire/register change from a value of zero (0) to one (1) and back from one (1) to zero (0) during simulation?\char`\"{}. A bit is said to be fully covered when it toggles back and forth at least once. This metric does not indicate to the user that every value of a multi-bit vector was seen. For example, if we have a two bit vector called \char`\"{}foo\char`\"{}, toggle coverage will not tell you that the value of foo was set to the values of 0, 1, 2 and 3. However, it will tell you that all bits in that vector were toggled back and forth.

 For a design to pass full coverage, it is recommended that the toggle coverage for all modules in a design received 100\% coverage. If a bit is never changes value, it is usually an indication that a mode is not being exercised in the design or a datapath has a stuck at issue.\end{Desc}
\begin{Desc}
\item[Combinational Logic Coverage Description]\par
 Combinational logic coverage answers the question, \char`\"{}What values did an expression (or  subexpression) evaluate to (or not evaluate to) during the course of the simulation?\char`\"{} This  type of coverage is extremely useful in determining logical combinations of signals that were  not tried during simulation, exposing potential holes in verification.

 For a design to pass full coverage, it is recommended that the combinational logic coverage for  all modules be 80\% or higher. If the expression coverage for an expression is not 100\%, it is recommended that the verification engineer closely examine this missed cases to determine if more testing is required. Sometimes certain combinations of signals are unachievable due to design constraints, keeping the expression coverage from ever reaching a value of 100\% but still can be considered full covered.\end{Desc}
\begin{Desc}
\item[Finite State Machine Coverage Description]\par
 Finite state machine coverage is particular coverage numbers for state machines within the design. There are two types of coverage detail for FSMs that Covered can handle:\begin{enumerate}
\item 
State coverage: answers the question \char`\"{}Were all states of an FSM hit during simulation?\char`\"{}\item 
State transition coverage: answers the question \char`\"{}Did the FSM transition between all states (that are achievable) in simulation?\char`\"{}\end{enumerate}
\end{Desc}


 For a design to pass full coverage, it is recommended that the FSM coverage for all finite state machines in the design to receive 100\% coverage for the state coverage and 100\% for all achievable state transitions. Since Covered will not determine which state transitions are achievable, it is up to the verification engineer to examine the executed state transitions to determine if 100\% of possible transitions occurred.

